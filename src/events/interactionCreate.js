import Logger from '../utils/Logger.js';
import { MessageFlags } from 'discord.js';
import ButtonHandler from '../handlers/ButtonHandler.js';
import { handleModal } from '../handlers/ModalHandler.js';
import TicketManager from '../managers/TicketManager.js';
import InteractionValidator from '../utils/InteractionValidator.js';
import CharteHandler from '../handlers/CharteHandler.js';

export default {
    name: 'interactionCreate',
    async execute(interaction) {
        const logger = new Logger();
        
        // Protection contre les doublons de Discord.js
        if (!interaction.client.interactionCache) {
            interaction.client.interactionCache = new Set();
        }
        
        const interactionKey = `${interaction.id}_${interaction.user.id}_${Date.now()}`;
        if (interaction.client.interactionCache.has(interaction.id)) {
            logger.warn(`üîÑ Interaction dupliqu√©e d√©tect√©e: ${interaction.id}`);
            return;
        }
        
        interaction.client.interactionCache.add(interaction.id);
        
        // Nettoyer le cache apr√®s 30 secondes
        setTimeout(() => {
            interaction.client.interactionCache.delete(interaction.id);
        }, 30000);
        
        // Initialiser le validateur d'interactions si n√©cessaire
        if (!interaction.client.interactionValidator) {
            interaction.client.interactionValidator = new InteractionValidator();
        }
        const validator = interaction.client.interactionValidator;
        
        try {
            // Validation robuste de l'interaction
            if (!validator.validateInteraction(interaction)) {
                return; // Interaction invalide, abandon silencieux
            }

            // Gestion des commandes slash
            if (interaction.isChatInputCommand()) {
                const command = interaction.client.commands.get(interaction.commandName);

                if (!command) {
                    logger.warn(`Commande inconnue: ${interaction.commandName}`);
                    return;
                }

                logger.command(interaction.user, interaction.commandName, interaction.guild);
                
                // V√©rification du cooldown
                const now = Date.now();
                const cooldownAmount = (command.cooldown ?? 3) * 1000;
                
                if (!interaction.client.cooldowns.has(interaction.commandName)) {
                    interaction.client.cooldowns.set(interaction.commandName, new Map());
                }
                
                const timestamps = interaction.client.cooldowns.get(interaction.commandName);
                
                if (timestamps.has(interaction.user.id)) {
                    const expirationTime = timestamps.get(interaction.user.id) + cooldownAmount;
                    
                    if (now < expirationTime) {
                        const timeLeft = (expirationTime - now) / 1000;
                        return await interaction.reply({
                            content: `‚è∞ Veuillez patienter ${timeLeft.toFixed(1)} seconde(s) avant de r√©utiliser cette commande.`,
                            flags: MessageFlags.Ephemeral
                        });
                    }
                }
                
                timestamps.set(interaction.user.id, now);
                
                await command.execute(interaction, interaction.client);
            }
            
            // Gestion de l'autocompl√©tion
            else if (interaction.isAutocomplete()) {
                const command = interaction.client.commands.get(interaction.commandName);
                
                if (!command || !command.autocomplete) {
                    return;
                }
                
                try {
                    await command.autocomplete(interaction);
                } catch (error) {
                    logger.error(`Erreur autocompl√©tion pour ${interaction.commandName}:`, error);
                }
            }
            
            // Gestion des boutons - ULTRA-S√âCURIS√âE
            else if (interaction.isButton()) {
                // V√©rification suppl√©mentaire avant traitement
                if (interaction.replied || interaction.deferred) {
                    logger.warn('‚ö†Ô∏è Interaction bouton d√©j√† trait√©e');
                    return;
                }

                logger.info(`üîò Bouton cliqu√©: ${interaction.customId} par ${interaction.user.tag}`);

                // Initialiser les gestionnaires si n√©cessaire
                if (!interaction.client.buttonHandler) {
                    interaction.client.buttonHandler = new ButtonHandler(interaction.client);
                }
                if (!interaction.client.ticketManager) {
                    interaction.client.ticketManager = new TicketManager(interaction.client);
                }

                // V√©rifier si c'est un bouton li√© aux streams
                if (interaction.customId.startsWith('stream_')) {
                    // Gestion basique des boutons de streams (si n√©cessaire)
                    logger.info('Bouton stream cliqu√© mais syst√®me d√©sactiv√©');
                    await interaction.reply({
                        content: '‚ùå Le syst√®me de streams n\'est pas disponible.',
                        ephemeral: true
                    });
                } else if (interaction.customId.startsWith('mod_')) {
                    // Gestion des boutons de mod√©ration
                    if (!interaction.client.moderationButtonHandler) {
                        logger.error('ModerationButtonHandler non initialis√©');
                        return;
                    }
                    await interaction.client.moderationButtonHandler.handleModerationButton(interaction);
                } else if (interaction.customId === 'charte_validate') {
                    // Gestion de la validation de charte
                    await CharteHandler.handleCharteValidation(interaction);
                } else if (interaction.customId.startsWith('delete_data_confirm_')) {
                    // Gestion de la confirmation de suppression de donn√©es
                    const userId = interaction.customId.split('_')[3];
                    await CharteHandler.handleDataDeletionConfirm(interaction, userId);
                } else if (interaction.customId.startsWith('delete_data_preview_')) {
                    // Gestion de l'aper√ßu des donn√©es √† supprimer
                    const userId = interaction.customId.split('_')[3];
                    await CharteHandler.handleDataPreview(interaction, userId);
                } else if (interaction.customId === 'delete_data_cancel') {
                    // Annulation de suppression de donn√©es
                    await interaction.update({
                        content: '‚ùå **Suppression annul√©e**\nAucune donn√©e n\'a √©t√© supprim√©e.',
                        embeds: [],
                        components: []
                    });
                } else if (interaction.customId === 'export_my_data') {
                    // Bouton "Exporter mes donn√©es" depuis /my-data
                    const exportCommand = interaction.client.commands?.get('export-my-data');
                    if (exportCommand) {
                        await exportCommand.execute(interaction);
                    } else {
                        await interaction.reply({
                            content: '‚ùå Erreur: Commande d\'export non trouv√©e.',
                            ephemeral: true
                        });
                    }
                } else if (interaction.customId === 'delete_my_data') {
                    // Bouton "Supprimer mes donn√©es" depuis /my-data
                    const deleteCommand = interaction.client.commands?.get('delete-my-data');
                    if (deleteCommand) {
                        await deleteCommand.execute(interaction);
                    } else {
                        await interaction.reply({
                            content: '‚ùå Erreur: Commande de suppression non trouv√©e.',
                            ephemeral: true
                        });
                    }
                } else if (interaction.customId === 'data_refresh') {
                    // Bouton "Actualiser" depuis /my-data
                    const myDataCommand = interaction.client.commands?.get('my-data');
                    if (myDataCommand) {
                        await myDataCommand.execute(interaction);
                    } else {
                        await interaction.reply({
                            content: '‚ùå Erreur: Commande my-data non trouv√©e.',
                            ephemeral: true
                        });
                    }
                } else if (interaction.customId.startsWith('export_before_delete_')) {
                    // Bouton "Exporter avant suppression" depuis l'aper√ßu des donn√©es
                    const userId = interaction.customId.split('_')[3];
                    const exportCommand = interaction.client.commands?.get('export-my-data');
                    if (exportCommand) {
                        await exportCommand.execute(interaction);
                    } else {
                        await interaction.reply({
                            content: '‚ùå Erreur: Commande d\'export non trouv√©e.',
                            ephemeral: true
                        });
                    }
                } else if (interaction.customId.startsWith('download_deletion_report_')) {
                    // Bouton "T√©l√©charger rapport" apr√®s suppression
                    const userId = interaction.customId.split('_')[3];
                    await interaction.reply({
                        content: 'üìã **Rapport de suppression**\n\nVotre rapport d√©taill√© a √©t√© envoy√© par message priv√©. Si vous ne l\'avez pas re√ßu, v√©rifiez vos param√®tres de confidentialit√©.',
                        ephemeral: true
                    });
                } else if (interaction.customId === 'gdpr_support') {
                    // Bouton "Support RGPD"
                    const supportCommand = interaction.client.commands?.get('support');
                    if (supportCommand) {
                        await supportCommand.execute(interaction);
                    } else {
                        await interaction.reply({
                            content: 'üìû **Support RGPD**\n\nPour toute question concernant vos donn√©es personnelles, contactez :\n‚Ä¢ **Support g√©n√©ral :** `/support`\n‚Ä¢ **Email DPO :** dpo@team7.gg\n‚Ä¢ **CNIL :** www.cnil.fr',
                            ephemeral: true
                        });
                    }
                } else {
                    await interaction.client.buttonHandler.handleButton(interaction);
                }
            }
            
            // Gestion des menus de s√©lection - S√âCURIS√âE
            else if (interaction.isStringSelectMenu()) {
                // V√©rification suppl√©mentaire avant traitement
                if (interaction.replied || interaction.deferred) {
                    logger.warn('‚ö†Ô∏è Interaction menu d√©j√† trait√©e');
                    return;
                }

                logger.info(`üìã Menu s√©lectionn√©: ${interaction.customId} par ${interaction.user.tag}`);

                // Utiliser une seule instance de TicketManager stock√©e dans le client
                if (!interaction.client.ticketManager) {
                    interaction.client.ticketManager = new TicketManager(interaction.client);
                }
                
                // V√©rifier si c'est un menu li√© aux streams
                if (interaction.customId.startsWith('stream_')) {
                    logger.info('Menu stream cliqu√© mais syst√®me d√©sactiv√©');
                    await interaction.reply({
                        content: '‚ùå Le syst√®me de streams n\'est pas disponible.',
                        ephemeral: true
                    });
                } else if (interaction.customId.startsWith('mod_')) {
                    // Gestion des menus de mod√©ration
                    if (!interaction.client.moderationButtonHandler) {
                        logger.error('ModerationButtonHandler non initialis√©');
                        return;
                    }
                    await interaction.client.moderationButtonHandler.handleModerationSelect(interaction);
                } else if (interaction.customId === 'suggestion_type_select') {
                    await interaction.client.ticketManager.handleSuggestionTypeSelect(interaction);
                } else if (interaction.customId === 'select_staff_invite') {
                    await interaction.client.ticketManager.handleStaffInviteSelection(interaction);
                } else if (interaction.customId === 'select_sos_staff_invite') {
                    await interaction.client.ticketManager.handleSOSStaffInviteSelection(interaction);
                } else {
                    logger.warn(`Menu non g√©r√©: ${interaction.customId}`);
                }
            }
            
            // Gestion des modals - S√âCURIS√âE
            else if (interaction.isModalSubmit()) {
                // V√©rification suppl√©mentaire avant traitement
                if (interaction.replied || interaction.deferred) {
                    logger.warn('‚ö†Ô∏è Interaction modal d√©j√† trait√©e');
                    return;
                }

                logger.info(`üìù Modal soumis: ${interaction.customId} par ${interaction.user.tag}`);

                // V√©rifier si c'est un modal li√© aux streams
                if (interaction.customId.startsWith('stream_')) {
                    logger.info('Modal stream soumis mais syst√®me d√©sactiv√©');
                    await interaction.reply({
                        content: '‚ùå Le syst√®me de streams n\'est pas disponible.',
                        ephemeral: true
                    });
                } else if (interaction.customId.startsWith('mod_')) {
                    // Gestion des modals de mod√©ration
                    if (!interaction.client.moderationButtonHandler) {
                        logger.error('ModerationButtonHandler non initialis√©');
                        return;
                    }
                    await interaction.client.moderationButtonHandler.handleModerationModal(interaction);
                } else {
                    // Initialiser le TicketManager si n√©cessaire
                    if (!interaction.client.ticketManager) {
                        interaction.client.ticketManager = new TicketManager(interaction.client);
                    }

                    await handleModal(interaction);
                }
            }
            
        } catch (error) {
            // Utiliser le validator pour une gestion d'erreur robuste
            await validator.handleInteractionError(interaction, error, 'interaction principale');
        } finally {
            // Marquer l'interaction comme termin√©e
            validator.markInteractionAsCompleted(interaction);
        }
    }
};
