import { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, PermissionFlagsBits } from 'discord.js';

export default {
    data: new SlashCommandBuilder()
        .setName('moderation')
        .setDescription('üõ°Ô∏è Syst√®me de mod√©ration complet')
        .setDefaultMemberPermissions(PermissionFlagsBits.ModerateMembers)
        .addSubcommand(subcommand =>
            subcommand
                .setName('panel')
                .setDescription('üéõÔ∏è Afficher le panel de mod√©ration principal')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('warn')
                .setDescription('‚ö†Ô∏è Avertir un utilisateur')
                .addUserOption(option =>
                    option
                        .setName('user')
                        .setDescription('üë§ Utilisateur √† avertir')
                        .setRequired(true))
                .addStringOption(option =>
                    option
                        .setName('reason')
                        .setDescription('üìù Raison de l\'avertissement')
                        .setRequired(true))
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('mute')
                .setDescription('üîá Mettre en sourdine un utilisateur')
                .addUserOption(option =>
                    option
                        .setName('user')
                        .setDescription('üë§ Utilisateur √† muter')
                        .setRequired(true))
                .addStringOption(option =>
                    option
                        .setName('reason')
                        .setDescription('üìù Raison du mute')
                        .setRequired(true))
                .addStringOption(option =>
                    option
                        .setName('duration')
                        .setDescription('‚è±Ô∏è Dur√©e (5m, 1h, 1d, 7d)')
                        .setRequired(false)
                        .addChoices(
                            { name: '5 minutes', value: '5m' },
                            { name: '1 heure', value: '1h' },
                            { name: '24 heures', value: '1d' },
                            { name: '7 jours', value: '7d' }
                        ))
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('kick')
                .setDescription('üë¢ Expulser un utilisateur')
                .addUserOption(option =>
                    option
                        .setName('user')
                        .setDescription('üë§ Utilisateur √† expulser')
                        .setRequired(true))
                .addStringOption(option =>
                    option
                        .setName('reason')
                        .setDescription('üìù Raison de l\'expulsion')
                        .setRequired(true))
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('ban')
                .setDescription('üî® Bannir un utilisateur')
                .addUserOption(option =>
                    option
                        .setName('user')
                        .setDescription('üë§ Utilisateur √† bannir')
                        .setRequired(true))
                .addStringOption(option =>
                    option
                        .setName('reason')
                        .setDescription('üìù Raison du bannissement')
                        .setRequired(true))
                .addStringOption(option =>
                    option
                        .setName('duration')
                        .setDescription('‚è±Ô∏è Dur√©e (vide = permanent)')
                        .setRequired(false)
                        .addChoices(
                            { name: '1 heure', value: '1h' },
                            { name: '24 heures', value: '1d' },
                            { name: '7 jours', value: '7d' },
                            { name: '30 jours', value: '30d' }
                        ))
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('unban')
                .setDescription('‚úÖ D√©bannir un utilisateur')
                .addStringOption(option =>
                    option
                        .setName('userid')
                        .setDescription('üÜî ID de l\'utilisateur √† d√©bannir')
                        .setRequired(true))
                .addStringOption(option =>
                    option
                        .setName('reason')
                        .setDescription('üìù Raison du d√©bannissement')
                        .setRequired(false))
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('history')
                .setDescription('üìã Voir l\'historique de mod√©ration d\'un utilisateur')
                .addUserOption(option =>
                    option
                        .setName('user')
                        .setDescription('üë§ Utilisateur √† consulter')
                        .setRequired(true))
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('stats')
                .setDescription('üìä Voir les statistiques de mod√©ration')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('config')
                .setDescription('‚öôÔ∏è Configuration du syst√®me de mod√©ration')
        ),

    async execute(interaction) {
        const subcommand = interaction.options.getSubcommand();
        const moderationManager = interaction.client.moderationManager;

        if (!moderationManager) {
            return await interaction.reply({
                content: '‚ùå Le syst√®me de mod√©ration n\'est pas initialis√©.',
                ephemeral: true
            });
        }

        // V√©rifier les permissions
        if (!interaction.member.permissions.has(PermissionFlagsBits.ModerateMembers)) {
            return await interaction.reply({
                content: '‚ùå Vous n\'avez pas les permissions n√©cessaires pour utiliser le syst√®me de mod√©ration.',
                ephemeral: true
            });
        }

        try {
            switch (subcommand) {
                case 'panel':
                    await this.handlePanel(interaction, moderationManager);
                    break;
                case 'warn':
                    await this.handleWarn(interaction, moderationManager);
                    break;
                case 'mute':
                    await this.handleMute(interaction, moderationManager);
                    break;
                case 'kick':
                    await this.handleKick(interaction, moderationManager);
                    break;
                case 'ban':
                    await this.handleBan(interaction, moderationManager);
                    break;
                case 'unban':
                    await this.handleUnban(interaction, moderationManager);
                    break;
                case 'history':
                    await this.handleHistory(interaction, moderationManager);
                    break;
                case 'stats':
                    await this.handleStats(interaction, moderationManager);
                    break;
                case 'config':
                    await this.handleConfig(interaction, moderationManager);
                    break;
            }
        } catch (error) {
            console.error('Erreur dans le syst√®me de mod√©ration:', error);
            
            const errorEmbed = new EmbedBuilder()
                .setTitle('‚ùå Erreur')
                .setDescription('Une erreur est survenue lors de l\'ex√©cution de la commande.')
                .setColor('#ff0000')
                .setTimestamp();

            if (interaction.deferred || interaction.replied) {
                await interaction.editReply({ embeds: [errorEmbed] });
            } else {
                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            }
        }
    },

    async handlePanel(interaction, moderationManager) {
        // R√©cup√©rer les statistiques actuelles
        const stats = await moderationManager.getStats();
        
        const embed = new EmbedBuilder()
            .setTitle('üõ°Ô∏è Panel de Mod√©ration Complet')
            .setDescription(`**Bienvenue dans le syst√®me de mod√©ration avanc√© !**\n\n` +
                           `üìä **Statistiques du jour :**\n` +
                           `‚Ä¢ Actions totales : **${stats.actionsToday}**\n` +
                           `‚Ä¢ Mutes actifs : **${stats.activeMutes}**\n` +
                           `‚Ä¢ Avertissements totaux : **${stats.totalWarnings}**\n\n` +
                           `S√©lectionnez une action de mod√©ration ci-dessous :`)
            .addFields(
                { 
                    name: '‚ö†Ô∏è Actions de Base', 
                    value: '‚Ä¢ **Avertir** - Donner un avertissement\n‚Ä¢ **Muter** - Mettre en sourdine temporaire\n‚Ä¢ **Kick** - Expulser du serveur', 
                    inline: true 
                },
                { 
                    name: 'üî® Actions S√©v√®res', 
                    value: '‚Ä¢ **Ban** - Bannissement permanent/temporaire\n‚Ä¢ **Unban** - D√©bannir un utilisateur\n‚Ä¢ **Unmute** - Retirer un mute', 
                    inline: true 
                },
                { 
                    name: 'üìã Gestion & Stats', 
                    value: '‚Ä¢ **Historique** - Voir l\'historique d\'un user\n‚Ä¢ **Statistiques** - Stats de mod√©ration\n‚Ä¢ **Configuration** - Param√®tres syst√®me', 
                    inline: true 
                }
            )
            .setColor('#3498db')
            .setTimestamp()
            .setFooter({ 
                text: `Syst√®me de mod√©ration ‚Ä¢ Utilis√© par ${interaction.user.tag}`,
                iconURL: interaction.user.displayAvatarURL()
            })
            .setThumbnail(interaction.guild.iconURL());

        const actionRow1 = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mod_warn_user')
                    .setLabel('Avertir')
                    .setEmoji('‚ö†Ô∏è')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('mod_mute_user')
                    .setLabel('Muter')
                    .setEmoji('üîá')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('mod_kick_user')
                    .setLabel('Kick')
                    .setEmoji('üë¢')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId('mod_ban_user')
                    .setLabel('Ban')
                    .setEmoji('üî®')
                    .setStyle(ButtonStyle.Danger)
            );

        const actionRow2 = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mod_unban_user')
                    .setLabel('Unban')
                    .setEmoji('‚úÖ')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId('mod_unmute_user')
                    .setLabel('Unmute')
                    .setEmoji('üîä')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId('mod_clear_warnings')
                    .setLabel('Clear Warns')
                    .setEmoji('üßπ')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('mod_quick_actions')
                    .setLabel('Actions Rapides')
                    .setEmoji('‚ö°')
                    .setStyle(ButtonStyle.Primary)
            );

        const actionRow3 = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mod_history_user')
                    .setLabel('Historique')
                    .setEmoji('üìã')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mod_stats')
                    .setLabel('Statistiques')
                    .setEmoji('üìä')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mod_config')
                    .setLabel('Configuration')
                    .setEmoji('‚öôÔ∏è')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('mod_refresh_panel')
                    .setLabel('Actualiser')
                    .setEmoji('üîÑ')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.reply({
            embeds: [embed],
            components: [actionRow1, actionRow2, actionRow3]
        });
    },

    async handleWarn(interaction, moderationManager) {
        await interaction.deferReply();

        const targetUser = interaction.options.getUser('user');
        const reason = interaction.options.getString('reason');

        // V√©rifications
        if (targetUser.id === interaction.user.id) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas vous avertir vous-m√™me.'
            });
        }

        if (targetUser.bot) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas avertir un bot.'
            });
        }

        if (!moderationManager.canModerate(interaction.member, { id: targetUser.id, guild: interaction.guild })) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas mod√©rer cet utilisateur (r√¥le sup√©rieur ou √©gal).'
            });
        }

        try {
            const warnData = await moderationManager.warnUser(
                interaction.guild,
                interaction.user,
                targetUser,
                reason
            );

            const warningCount = moderationManager.warnings.get(targetUser.id)?.filter(w => w.active).length || 0;

            const embed = new EmbedBuilder()
                .setTitle('‚ö†Ô∏è Avertissement donn√©')
                .setDescription(`**${targetUser.tag}** a √©t√© averti avec succ√®s.`)
                .addFields(
                    { name: 'üë§ Utilisateur', value: `${targetUser.tag} (${targetUser.id})`, inline: true },
                    { name: 'üõ°Ô∏è Mod√©rateur', value: `${interaction.user.tag}`, inline: true },
                    { name: 'üìù Raison', value: reason, inline: false },
                    { name: 'üìä Total des avertissements', value: `${warningCount}`, inline: true }
                )
                .setColor('#ffff00')
                .setTimestamp()
                .setFooter({ text: `ID: ${warnData.id}` });

            if (warningCount >= 3) {
                embed.addFields({
                    name: 'üö® Attention',
                    value: 'Cet utilisateur a maintenant 3 avertissements ou plus. Des actions automatiques peuvent √™tre d√©clench√©es.',
                    inline: false
                });
            }

            await interaction.editReply({ embeds: [embed] });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur lors de l'avertissement: ${error.message}`
            });
        }
    },

    async handleMute(interaction, moderationManager) {
        await interaction.deferReply();

        const targetUser = interaction.options.getUser('user');
        const durationStr = interaction.options.getString('duration') || '1h';
        const reason = interaction.options.getString('reason');

        // Convertir la dur√©e
        const duration = this.parseDuration(durationStr);

        // V√©rifications
        if (targetUser.id === interaction.user.id) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas vous muter vous-m√™me.'
            });
        }

        if (targetUser.bot) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas muter un bot.'
            });
        }

        try {
            const muteData = await moderationManager.muteUser(
                interaction.guild,
                interaction.user,
                targetUser,
                reason,
                duration
            );

            const embed = new EmbedBuilder()
                .setTitle('üîá Utilisateur mis en sourdine')
                .setDescription(`**${targetUser.tag}** a √©t√© mis en sourdine avec succ√®s.`)
                .addFields(
                    { name: 'üë§ Utilisateur', value: `${targetUser.tag} (${targetUser.id})`, inline: true },
                    { name: 'üõ°Ô∏è Mod√©rateur', value: `${interaction.user.tag}`, inline: true },
                    { name: '‚è±Ô∏è Dur√©e', value: moderationManager.formatDuration(duration), inline: true },
                    { name: 'üìù Raison', value: reason, inline: false }
                )
                .setColor('#ff8c00')
                .setTimestamp()
                .setFooter({ text: `ID: ${muteData.id}` });

            await interaction.editReply({ embeds: [embed] });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur lors du mute: ${error.message}`
            });
        }
    },

    async handleKick(interaction, moderationManager) {
        await interaction.deferReply();

        const targetUser = interaction.options.getUser('user');
        const reason = interaction.options.getString('reason');

        // V√©rifications
        if (targetUser.id === interaction.user.id) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas vous expulser vous-m√™me.'
            });
        }

        if (targetUser.bot) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas expulser un bot.'
            });
        }

        try {
            const kickData = await moderationManager.kickUser(
                interaction.guild,
                interaction.user,
                targetUser,
                reason
            );

            const embed = new EmbedBuilder()
                .setTitle('üë¢ Utilisateur expuls√©')
                .setDescription(`**${targetUser.tag}** a √©t√© expuls√© du serveur.`)
                .addFields(
                    { name: 'üë§ Utilisateur', value: `${targetUser.tag} (${targetUser.id})`, inline: true },
                    { name: 'üõ°Ô∏è Mod√©rateur', value: `${interaction.user.tag}`, inline: true },
                    { name: 'üìù Raison', value: reason, inline: false }
                )
                .setColor('#ff8c00')
                .setTimestamp()
                .setFooter({ text: `ID: ${kickData.id}` });

            await interaction.editReply({ embeds: [embed] });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur lors de l'expulsion: ${error.message}`
            });
        }
    },

    async handleBan(interaction, moderationManager) {
        await interaction.deferReply();

        const targetUser = interaction.options.getUser('user');
        const reason = interaction.options.getString('reason');
        const durationStr = interaction.options.getString('duration');
        const duration = durationStr ? this.parseDuration(durationStr) : null;

        // V√©rifications
        if (targetUser.id === interaction.user.id) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas vous bannir vous-m√™me.'
            });
        }

        if (targetUser.bot) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas bannir un bot.'
            });
        }

        try {
            const banData = await moderationManager.banUser(
                interaction.guild,
                interaction.user,
                targetUser,
                reason,
                duration
            );

            const embed = new EmbedBuilder()
                .setTitle('üî® Utilisateur banni')
                .setDescription(`**${targetUser.tag}** a √©t√© banni du serveur.`)
                .addFields(
                    { name: 'üë§ Utilisateur', value: `${targetUser.tag} (${targetUser.id})`, inline: true },
                    { name: 'üõ°Ô∏è Mod√©rateur', value: `${interaction.user.tag}`, inline: true },
                    { name: 'üìù Raison', value: reason, inline: false }
                )
                .setColor('#ff0000')
                .setTimestamp()
                .setFooter({ text: `ID: ${banData.id}` });

            if (duration) {
                embed.addFields({
                    name: '‚è±Ô∏è Dur√©e',
                    value: `${moderationManager.formatDuration(duration)} (temporaire)`,
                    inline: true
                });
            } else {
                embed.addFields({
                    name: '‚è±Ô∏è Dur√©e',
                    value: 'Permanent',
                    inline: true
                });
            }

            await interaction.editReply({ embeds: [embed] });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur lors du bannissement: ${error.message}`
            });
        }
    },

    async handleUnban(interaction, moderationManager) {
        await interaction.deferReply();

        const userIdStr = interaction.options.getString('userid');
        const reason = interaction.options.getString('reason') || 'Aucune raison sp√©cifi√©e';

        // V√©rifier que c'est un ID valide
        if (!/^\d{17,19}$/.test(userIdStr)) {
            return await interaction.editReply({
                content: '‚ùå ID utilisateur invalide. Veuillez fournir un ID Discord valide.'
            });
        }

        try {
            // V√©rifier si l'utilisateur est banni
            const bans = await interaction.guild.bans.fetch();
            const bannedUser = bans.get(userIdStr);

            if (!bannedUser) {
                return await interaction.editReply({
                    content: '‚ùå Cet utilisateur n\'est pas banni sur ce serveur.'
                });
            }

            const targetUser = bannedUser.user;

            const unbanData = await moderationManager.unbanUser(
                interaction.guild,
                interaction.user,
                targetUser,
                reason
            );

            const embed = new EmbedBuilder()
                .setTitle('‚úÖ Utilisateur d√©banni')
                .setDescription(`**${targetUser.tag}** a √©t√© d√©banni du serveur.`)
                .addFields(
                    { name: 'üë§ Utilisateur', value: `${targetUser.tag} (${targetUser.id})`, inline: true },
                    { name: 'üõ°Ô∏è Mod√©rateur', value: `${interaction.user.tag}`, inline: true },
                    { name: 'üìù Raison', value: reason, inline: false }
                )
                .setColor('#00ff00')
                .setTimestamp()
                .setFooter({ text: `ID: ${unbanData.id}` });

            await interaction.editReply({ embeds: [embed] });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur lors du d√©bannissement: ${error.message}`
            });
        }
    },

    async handleHistory(interaction, moderationManager) {
        await interaction.deferReply();

        const targetUser = interaction.options.getUser('user');
        const history = await moderationManager.getUserHistory(targetUser.id);
        const warnings = await moderationManager.getUserWarnings(targetUser.id);

        if (history.length === 0 && warnings.length === 0) {
            const embed = new EmbedBuilder()
                .setTitle('üìã Historique de mod√©ration')
                .setDescription(`**${targetUser.tag}** n'a aucun ant√©c√©dent de mod√©ration.`)
                .setColor('#00ff00')
                .setTimestamp();

            return await interaction.editReply({ embeds: [embed] });
        }

        const embed = new EmbedBuilder()
            .setTitle('üìã Historique de mod√©ration')
            .setDescription(`Historique de **${targetUser.tag}** (${targetUser.id})`)
            .setColor('#3498db')
            .setTimestamp();

        // Avertissements actifs
        const activeWarnings = warnings.filter(w => w.active);
        if (activeWarnings.length > 0) {
            embed.addFields({
                name: `‚ö†Ô∏è Avertissements actifs (${activeWarnings.length})`,
                value: activeWarnings.slice(0, 5).map(w => 
                    `‚Ä¢ ${w.reason} - <t:${Math.floor(w.timestamp / 1000)}:R>`
                ).join('\n') + (activeWarnings.length > 5 ? `\n... et ${activeWarnings.length - 5} autre(s)` : ''),
                inline: false
            });
        }

        // Historique r√©cent
        const recentHistory = history.slice(-10).reverse();
        if (recentHistory.length > 0) {
            embed.addFields({
                name: `üìú Historique r√©cent (${recentHistory.length}/${history.length})`,
                value: recentHistory.map(h => {
                    const action = h.type.toUpperCase();
                    const timestamp = `<t:${Math.floor(h.timestamp / 1000)}:R>`;
                    const reason = h.data.reason?.substring(0, 50) || 'Aucune raison';
                    return `‚Ä¢ **${action}** - ${reason} ${timestamp}`;
                }).join('\n'),
                inline: false
            });
        }

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`mod_history_full_${targetUser.id}`)
                    .setLabel('üìÑ Historique complet')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId(`mod_clear_warnings_${targetUser.id}`)
                    .setLabel('üßπ Effacer les avertissements')
                    .setStyle(ButtonStyle.Danger)
                    .setDisabled(activeWarnings.length === 0)
            );

        await interaction.editReply({ 
            embeds: [embed],
            components: [actionRow]
        });
    },

    async handleStats(interaction, moderationManager) {
        await interaction.deferReply();

        const stats = await moderationManager.getStats();

        const embed = new EmbedBuilder()
            .setTitle('üìä Statistiques de mod√©ration')
            .setDescription('Statistiques du syst√®me de mod√©ration')
            .addFields(
                { name: 'üìà Actions totales', value: stats.totalActions.toString(), inline: true },
                { name: 'üìÖ Actions aujourd\'hui', value: stats.actionsToday.toString(), inline: true },
                { name: 'üîá Mutes actifs', value: stats.activeMutes.toString(), inline: true },
                { name: '‚ö†Ô∏è Avertissements', value: stats.actionTypes.warn.toString(), inline: true },
                { name: 'üîá Mutes', value: stats.actionTypes.mute.toString(), inline: true },
                { name: 'üë¢ Kicks', value: stats.actionTypes.kick.toString(), inline: true },
                { name: 'üî® Bans', value: stats.actionTypes.ban.toString(), inline: true },
                { name: '‚úÖ Unbans', value: stats.actionTypes.unban.toString(), inline: true },
                { name: 'üìä Total avertissements', value: stats.totalWarnings.toString(), inline: true }
            )
            .setColor('#9b59b6')
            .setTimestamp()
            .setFooter({ text: `Statistiques mises √† jour ‚Ä¢ ${stats.lastResetDate}` });

        await interaction.editReply({ embeds: [embed] });
    },

    async handleConfig(interaction, moderationManager) {
        const configEmbed = new EmbedBuilder()
            .setTitle('‚öôÔ∏è Configuration du syst√®me de mod√©ration')
            .setDescription('Configurez les param√®tres du syst√®me de mod√©ration')
            .addFields(
                { name: 'üìù Canal de logs', value: 'D√©finir le canal pour les logs de mod√©ration', inline: false },
                { name: 'üö® Actions automatiques', value: 'Configurer les sanctions automatiques', inline: false },
                { name: '‚è±Ô∏è Dur√©es par d√©faut', value: 'Modifier les dur√©es de timeout par d√©faut', inline: false }
            )
            .setColor('#3498db');

        const configRow = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('mod_config_select')
                    .setPlaceholder('S√©lectionnez une option de configuration')
                    .addOptions(
                        {
                            label: 'üìù Canal de logs',
                            description: 'D√©finir le canal pour les logs',
                            value: 'log_channel'
                        },
                        {
                            label: 'üö® Actions automatiques',
                            description: 'Configurer les sanctions auto',
                            value: 'auto_actions'
                        },
                        {
                            label: '‚è±Ô∏è Dur√©es par d√©faut',
                            description: 'Modifier les dur√©es de timeout',
                            value: 'default_durations'
                        },
                        {
                            label: 'üìä R√©initialiser les stats',
                            description: 'Remettre √† z√©ro les statistiques',
                            value: 'reset_stats'
                        }
                    )
            );

        await interaction.reply({ 
            embeds: [configEmbed], 
            components: [configRow],
            ephemeral: true 
        });
    },

    // Utilitaire pour parser les dur√©es
    parseDuration(durationStr) {
        const match = durationStr.match(/^(\d+)([mhd])$/);
        if (!match) return 3600000; // 1 heure par d√©faut

        const [, amount, unit] = match;
        const multipliers = {
            'm': 60 * 1000,           // minutes
            'h': 60 * 60 * 1000,      // heures
            'd': 24 * 60 * 60 * 1000  // jours
        };

        return parseInt(amount) * multipliers[unit];
    }
};
