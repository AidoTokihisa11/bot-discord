import { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits, ChannelType } from 'discord.js';

export default {
    data: new SlashCommandBuilder()
        .setName('stream-notifications')
        .setDescription('üéÆ G√©rer les notifications de streamers en live')
        .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels)
        .addSubcommand(subcommand =>
            subcommand
                .setName('add')
                .setDescription('‚ûï Ajouter un streamer √† surveiller')
                .addStringOption(option =>
                    option
                        .setName('platform')
                        .setDescription('Plateforme de streaming')
                        .setRequired(true)
                        .addChoices(
                            { name: 'üü£ Twitch', value: 'twitch' },
                            { name: 'üî¥ YouTube', value: 'youtube' },
                            { name: 'üéØ Kick', value: 'kick' }
                        )
                )
                .addStringOption(option =>
                    option
                        .setName('username')
                        .setDescription('Nom d\'utilisateur du streamer')
                        .setRequired(true)
                )
                .addChannelOption(option =>
                    option
                        .setName('channel')
                        .setDescription('Canal o√π envoyer les notifications')
                        .setRequired(true)
                        .addChannelTypes(ChannelType.GuildText, ChannelType.GuildAnnouncement)
                )
                .addRoleOption(option =>
                    option
                        .setName('role')
                        .setDescription('R√¥le √† mentionner (optionnel)')
                        .setRequired(false)
                )
                .addStringOption(option =>
                    option
                        .setName('custom-message')
                        .setDescription('Message personnalis√© (optionnel)')
                        .setRequired(false)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('remove')
                .setDescription('‚ûñ Supprimer un streamer de la surveillance')
                .addStringOption(option =>
                    option
                        .setName('platform')
                        .setDescription('Plateforme de streaming')
                        .setRequired(true)
                        .addChoices(
                            { name: 'üü£ Twitch', value: 'twitch' },
                            { name: 'üî¥ YouTube', value: 'youtube' },
                            { name: 'üéØ Kick', value: 'kick' }
                        )
                )
                .addStringOption(option =>
                    option
                        .setName('username')
                        .setDescription('Nom d\'utilisateur du streamer')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('list')
                .setDescription('üìã Afficher tous les streamers surveill√©s')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('test')
                .setDescription('üß™ Tester une notification de stream')
                .addStringOption(option =>
                    option
                        .setName('platform')
                        .setDescription('Plateforme de streaming')
                        .setRequired(true)
                        .addChoices(
                            { name: 'üü£ Twitch', value: 'twitch' },
                            { name: 'üî¥ YouTube', value: 'youtube' },
                            { name: 'üéØ Kick', value: 'kick' }
                        )
                )
                .addStringOption(option =>
                    option
                        .setName('username')
                        .setDescription('Nom d\'utilisateur du streamer')
                        .setRequired(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('status')
                .setDescription('üìä Statut du syst√®me de notifications')
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('demo')
                .setDescription('üé¨ D√©clencher une d√©monstration avec notifications fictives')
                .addChannelOption(option =>
                    option
                        .setName('channel')
                        .setDescription('Canal o√π envoyer les notifications de d√©mo')
                        .setRequired(true)
                        .addChannelTypes(ChannelType.GuildText, ChannelType.GuildAnnouncement)
                )
        ),

    async execute(interaction) {
        try {
            await interaction.deferReply({ ephemeral: true });

            const subcommand = interaction.options.getSubcommand();
            const streamManager = interaction.client.streamManager;

            if (!streamManager) {
                return await interaction.editReply({
                    content: '‚ùå Le syst√®me de notifications de stream n\'est pas initialis√©.'
                });
            }

            switch (subcommand) {
                case 'add':
                    await handleAddStreamer(interaction, streamManager);
                    break;
                case 'remove':
                    await handleRemoveStreamer(interaction, streamManager);
                    break;
                case 'list':
                    await handleListStreamers(interaction, streamManager);
                    break;
                case 'test':
                    await handleTestNotification(interaction, streamManager);
                    break;
                case 'status':
                    await handleStatus(interaction, streamManager);
                    break;
                case 'demo':
                    await handleDemo(interaction, streamManager);
                    break;
                default:
                    await interaction.editReply({
                        content: '‚ùå Sous-commande non reconnue.'
                    });
            }

        } catch (error) {
            console.error('Erreur dans stream-notifications:', error);
            await interaction.editReply({
                content: '‚ùå Une erreur est survenue lors de l\'ex√©cution de la commande.'
            });
        }
    }
};

async function handleAddStreamer(interaction, streamManager) {
    const platform = interaction.options.getString('platform');
    const username = interaction.options.getString('username');
    const channel = interaction.options.getChannel('channel');
    const role = interaction.options.getRole('role');
    const customMessage = interaction.options.getString('custom-message');

    try {
        // V√©rifier si le streamer existe et est valide
        const streamerInfo = await streamManager.validateStreamer(platform, username);
        
        if (!streamerInfo.exists) {
            return await interaction.editReply({
                content: `‚ùå Le streamer \`${username}\` n'existe pas sur **${platform.toUpperCase()}**.`
            });
        }

        // Ajouter le streamer
        const result = await streamManager.addStreamer(
            interaction.guild.id,
            platform,
            username,
            channel.id,
            role?.id,
            customMessage
        );

        if (result.success) {
            const embed = new EmbedBuilder()
                .setColor('#00ff88')
                .setTitle('‚úÖ Streamer ajout√© avec succ√®s!')
                .setDescription(`**${streamerInfo.displayName || username}** sera maintenant surveill√©`)
                .addFields(
                    { name: 'üéÆ Plateforme', value: platform.toUpperCase(), inline: true },
                    { name: 'üë§ Streamer', value: streamerInfo.displayName || username, inline: true },
                    { name: 'üì¢ Canal', value: `${channel}`, inline: true }
                )
                .setThumbnail(streamerInfo.avatar || null)
                .setTimestamp();

            if (role) {
                embed.addFields({ name: 'üè∑Ô∏è R√¥le √† mentionner', value: `${role}`, inline: true });
            }

            if (customMessage) {
                embed.addFields({ name: 'üí¨ Message personnalis√©', value: customMessage, inline: false });
            }

            await interaction.editReply({ embeds: [embed] });
        } else {
            await interaction.editReply({
                content: `‚ùå ${result.error || 'Erreur lors de l\'ajout du streamer.'}`
            });
        }

    } catch (error) {
        console.error('Erreur lors de l\'ajout du streamer:', error);
        await interaction.editReply({
            content: '‚ùå Erreur lors de la validation du streamer.'
        });
    }
}

async function handleRemoveStreamer(interaction, streamManager) {
    const platform = interaction.options.getString('platform');
    const username = interaction.options.getString('username');

    const result = await streamManager.removeStreamer(
        interaction.guild.id,
        platform,
        username
    );

    if (result.success) {
        const embed = new EmbedBuilder()
            .setColor('#ff4444')
            .setTitle('‚úÖ Streamer supprim√©')
            .setDescription(`**${username}** ne sera plus surveill√© sur **${platform.toUpperCase()}**`)
            .setTimestamp();

        await interaction.editReply({ embeds: [embed] });
    } else {
        await interaction.editReply({
            content: `‚ùå ${result.error || 'Streamer non trouv√©.'}`
        });
    }
}

async function handleListStreamers(interaction, streamManager) {
    const streamers = await streamManager.getStreamers(interaction.guild.id);

    if (streamers.length === 0) {
        return await interaction.editReply({
            content: 'üìã Aucun streamer configur√© pour ce serveur.'
        });
    }

    const embed = new EmbedBuilder()
        .setColor('#0099ff')
        .setTitle('üìã Streamers surveill√©s')
        .setDescription(`**${streamers.length}** streamer(s) configur√©(s)`)
        .setTimestamp();

    // Grouper par plateforme
    const platforms = {};
    streamers.forEach(streamer => {
        if (!platforms[streamer.platform]) {
            platforms[streamer.platform] = [];
        }
        platforms[streamer.platform].push(streamer);
    });

    Object.entries(platforms).forEach(([platform, streamers]) => {
        const platformEmoji = {
            'twitch': 'üü£',
            'youtube': 'üî¥',
            'kick': 'üéØ'
        };

        const streamerList = streamers.map(s => 
            `‚Ä¢ **${s.username}** ‚Üí <#${s.channelId}>${s.roleId ? ` (${s.roleId})` : ''}`
        ).join('\n');

        embed.addFields({
            name: `${platformEmoji[platform] || 'üéÆ'} ${platform.toUpperCase()}`,
            value: streamerList,
            inline: false
        });
    });

    await interaction.editReply({ embeds: [embed] });
}

async function handleTestNotification(interaction, streamManager) {
    const platform = interaction.options.getString('platform');
    const username = interaction.options.getString('username');

    try {
        const result = await streamManager.sendTestNotification(
            interaction.guild.id,
            platform,
            username
        );

        if (result.success) {
            await interaction.editReply({
                content: `‚úÖ Notification de test envoy√©e pour **${username}** sur **${platform.toUpperCase()}**!`
            });
        } else {
            await interaction.editReply({
                content: `‚ùå ${result.error || 'Impossible d\'envoyer la notification de test.'}`
            });
        }

    } catch (error) {
        console.error('Erreur lors du test:', error);
        await interaction.editReply({
            content: '‚ùå Erreur lors de l\'envoi de la notification de test.'
        });
    }
}

async function handleStatus(interaction, streamManager) {
    const stats = await streamManager.getStats(interaction.guild.id);
    
    const embed = new EmbedBuilder()
        .setColor('#00ff88')
        .setTitle('üìä Statut du syst√®me de notifications')
        .addFields(
            { name: 'üë• Streamers surveill√©s', value: `${stats.totalStreamers}`, inline: true },
            { name: 'üü¢ Actuellement en live', value: `${stats.currentlyLive}`, inline: true },
            { name: 'üì¢ Notifications envoy√©es', value: `${stats.notificationsSent}`, inline: true },
            { name: '‚è±Ô∏è Derni√®re v√©rification', value: `<t:${Math.floor(stats.lastCheck / 1000)}:R>`, inline: true },
            { name: 'üîÑ Intervalle de v√©rification', value: '2 minutes', inline: true },
            { name: 'üìä Statut', value: stats.isRunning ? 'üü¢ Actif' : 'üî¥ Arr√™t√©', inline: true }
        )
        .setTimestamp();

    if (stats.platforms) {
        const platformStats = Object.entries(stats.platforms)
            .map(([platform, count]) => `${platform.toUpperCase()}: ${count}`)
            .join('\n');
        
        embed.addFields({
            name: 'üéÆ Par plateforme',
            value: platformStats || 'Aucune',
            inline: false
        });
    }

    await interaction.editReply({ embeds: [embed] });
}

async function handleDemo(interaction, streamManager) {
    const channel = interaction.options.getChannel('channel');

    try {
        // Cr√©er des streamers fictifs pour la d√©mo
        const demoStreamers = [
            { platform: 'twitch', username: 'ninja', displayName: 'Ninja' },
            { platform: 'twitch', username: 'pokimane', displayName: 'Pokimane' },
            { platform: 'youtube', username: 'mrbeast', displayName: 'MrBeast' },
            { platform: 'kick', username: 'adin', displayName: 'Adin Ross' }
        ];

        let sentNotifications = 0;

        for (const streamer of demoStreamers) {
            // Cr√©er des donn√©es de stream fictives
            const demoStreamData = streamManager.createDemoStreamData(streamer.platform, streamer.username);
            
            // Cr√©er un objet streamer temporaire
            const tempStreamer = {
                guildId: interaction.guild.id,
                platform: streamer.platform,
                username: streamer.username,
                channelId: channel.id,
                customMessage: `üé¨ D√âMO - ${streamer.displayName} est en live !`
            };

            // Envoyer la notification
            await streamManager.sendStreamNotification(tempStreamer, demoStreamData, streamer.platform);
            sentNotifications++;

            // Petite pause entre les notifications
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        const embed = new EmbedBuilder()
            .setColor('#00ff88')
            .setTitle('üé¨ D√©monstration lanc√©e !')
            .setDescription(`**${sentNotifications} notifications de d√©mo** ont √©t√© envoy√©es dans ${channel}`)
            .addFields(
                { name: 'üéÆ Plateformes test√©es', value: 'Twitch, YouTube, Kick', inline: true },
                { name: 'üì¢ Canal', value: `${channel}`, inline: true },
                { name: '‚ö° Type', value: 'Notifications fictives', inline: true }
            )
            .setFooter({ text: 'Ces notifications sont uniquement pour la d√©monstration' })
            .setTimestamp();

        await interaction.editReply({ embeds: [embed] });

    } catch (error) {
        console.error('Erreur lors de la d√©mo:', error);
        await interaction.editReply({
            content: '‚ùå Erreur lors de la d√©monstration.'
        });
    }
}
