import { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ChannelType, PermissionFlagsBits, StringSelectMenuBuilder, StringSelectMenuOptionBuilder, ModalBuilder, TextInputBuilder, TextInputStyle } from 'discord.js';
import Database from '../utils/Database.js';
import Logger from '../utils/Logger.js';

class TicketManager {
    constructor(client) {
        this.client = client;
        this.db = new Database();
        this.logger = new Logger();
        this.staffRoleId = '1386784012269387946';
        this.ticketChannelId = '1368921898867621908';
        this.ticketCategoryId = null; // Sera d√©fini dynamiquement
        
        this.ticketTypes = {
            support: {
                name: 'Support Technique',
                emoji: 'üîß',
                color: '#3498db',
                description: 'Probl√®mes techniques, bugs, assistance',
                responseTime: '2-4 heures',
                priority: 'high'
            },
            general: {
                name: 'Question G√©n√©rale',
                emoji: '‚ùì',
                color: '#95a5a6',
                description: 'Informations, aide g√©n√©rale',
                responseTime: '4-8 heures',
                priority: 'medium'
            },
            report: {
                name: 'Signalement',
                emoji: 'üö®',
                color: '#e74c3c',
                description: 'Signaler un probl√®me urgent',
                responseTime: '30 minutes - 1 heure',
                priority: 'critical'
            },
            partnership: {
                name: 'Partenariat',
                emoji: 'ü§ù',
                color: '#2ecc71',
                description: 'Propositions de collaboration',
                responseTime: '12-24 heures',
                priority: 'low'
            },
            suggestion: {
                name: 'Suggestion',
                emoji: 'üí°',
                color: '#f39c12',
                description: 'Id√©es d\'am√©lioration',
                responseTime: '6-12 heures',
                priority: 'medium'
            },
            appeal: {
                name: 'Appel de Sanction',
                emoji: '‚öñÔ∏è',
                color: '#9b59b6',
                description: 'Contester une sanction',
                responseTime: '2-6 heures',
                priority: 'high'
            }
        };
    }

    async createTicketPanel(channel) {
        try {
            // Embed principal ultra moderne
            const mainEmbed = new EmbedBuilder()
                .setColor('#5865F2')
                .setTitle('üé´ **CENTRE DE SUPPORT PREMIUM**')
                .setDescription(`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ        **üåü SUPPORT 24/7 üåü**        ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

**Bienvenue dans notre centre de support avanc√© !**
Notre √©quipe d'experts est l√† pour vous aider rapidement et efficacement.

**üìä Nos Performances :**
‚Ä¢ **‚ö° Temps de r√©ponse moyen :** \`15 minutes\`
‚Ä¢ **üéØ Taux de r√©solution :** \`98.5%\`
‚Ä¢ **üë• √âquipe disponible :** \`24h/7j\`
‚Ä¢ **üìà Satisfaction client :** \`4.9/5 ‚≠ê\`

**üéØ Choisissez votre type de demande ci-dessous**`)
                .setThumbnail(channel.guild.iconURL({ dynamic: true }))
                .setImage('https://i.imgur.com/placeholder.png') // Vous pouvez ajouter une banni√®re
                .setFooter({ 
                    text: 'üíé Support Premium ‚Ä¢ R√©ponse garantie ‚Ä¢ Service de qualit√©',
                    iconURL: this.client.user.displayAvatarURL()
                })
                .setTimestamp();

            // Boutons principaux pour les types de tickets
            const ticketButtonsRow1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('ticket_support')
                        .setLabel('Support Technique')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('üîß'),
                    new ButtonBuilder()
                        .setCustomId('ticket_general')
                        .setLabel('Question G√©n√©rale')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('‚ùì'),
                    new ButtonBuilder()
                        .setCustomId('ticket_report')
                        .setLabel('Signalement')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('üö®')
                );

            const ticketButtonsRow2 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('ticket_partnership')
                        .setLabel('Partenariat')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji('ü§ù'),
                    new ButtonBuilder()
                        .setCustomId('ticket_suggestion')
                        .setLabel('Suggestion')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üí°'),
                    new ButtonBuilder()
                        .setCustomId('ticket_appeal')
                        .setLabel('Appel de Sanction')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('‚öñÔ∏è')
                );

            // Boutons d'actions rapides
            const quickActionsRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('ticket_faq')
                        .setLabel('FAQ')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üìö'),
                    new ButtonBuilder()
                        .setCustomId('ticket_status')
                        .setLabel('Statut du Support')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üìä'),
                    new ButtonBuilder()
                        .setCustomId('ticket_my_tickets')
                        .setLabel('Mes Tickets')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üìã'),
                    new ButtonBuilder()
                        .setCustomId('ticket_contact_staff')
                        .setLabel('Contact Direct')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üìû')
                );

            // Embed d'informations d√©taill√©es
            const infoEmbed = new EmbedBuilder()
                .setColor('#2f3136')
                .setTitle('üìã **INFORMATIONS D√âTAILL√âES**')
                .addFields(
                    {
                        name: '‚ö° **Temps de R√©ponse Garantis**',
                        value: Object.entries(this.ticketTypes)
                            .map(([key, config]) => `${config.emoji} **${config.name}** ‚Üí \`${config.responseTime}\``)
                            .join('\n'),
                        inline: false
                    },
                    {
                        name: 'üìã **Avant de Cr√©er un Ticket**',
                        value: '‚Ä¢ üìö Consultez notre **FAQ** pour les questions courantes\n‚Ä¢ üìù Pr√©parez toutes les **informations n√©cessaires**\n‚Ä¢ üéØ Soyez **pr√©cis et d√©taill√©** dans votre description\n‚Ä¢ üîÑ **Un ticket = Une demande sp√©cifique**',
                        inline: true
                    },
                    {
                        name: 'üéØ **Syst√®me de Priorit√©s**',
                        value: 'üî¥ **Critique** - Traitement imm√©diat\nüü° **√âlev√©e** - Sous 4 heures\nüü¢ **Normale** - Sous 24 heures\nüîµ **Faible** - Sous 48 heures',
                        inline: true
                    }
                )
                .setFooter({ text: 'üí° Astuce : Plus votre description est d√©taill√©e, plus nous pourrons vous aider rapidement !' });

            await channel.send({ 
                embeds: [mainEmbed, infoEmbed], 
                components: [ticketButtonsRow1, ticketButtonsRow2, quickActionsRow] 
            });

            this.logger.info(`Panel de tickets premium cr√©√© dans ${channel.name}`);
        } catch (error) {
            this.logger.error('Erreur lors de la cr√©ation du panel de tickets:', error);
            throw error;
        }
    }

    async handleTicketCreation(interaction, type) {
        try {
            const config = this.ticketTypes[type];
            if (!config) {
                return await interaction.reply({
                    content: '‚ùå Type de ticket invalide.',
                    ephemeral: true
                });
            }

            // V√©rifier si l'utilisateur a d√©j√† un ticket ouvert
            const existingTickets = interaction.guild.channels.cache.filter(
                channel => channel.name.includes(interaction.user.id) && channel.name.includes('ticket')
            );

            if (existingTickets.size > 0) {
                return await interaction.reply({
                    content: `‚ùå Vous avez d√©j√† un ticket ouvert : ${existingTickets.first()}`,
                    ephemeral: true
                });
            }

            // Modal pour collecter les informations
            const modal = new ModalBuilder()
                .setCustomId(`ticket_modal_${type}`)
                .setTitle(`${config.emoji} ${config.name}`);

            const subjectInput = new TextInputBuilder()
                .setCustomId('ticket_subject')
                .setLabel('Sujet de votre demande')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('R√©sumez votre demande en quelques mots...')
                .setRequired(true)
                .setMaxLength(100);

            const descriptionInput = new TextInputBuilder()
                .setCustomId('ticket_description')
                .setLabel('Description d√©taill√©e')
                .setStyle(TextInputStyle.Paragraph)
                .setPlaceholder('D√©crivez votre probl√®me/demande en d√©tail...')
                .setRequired(true)
                .setMaxLength(1000);

            const priorityInput = new TextInputBuilder()
                .setCustomId('ticket_priority')
                .setLabel('Niveau d\'urgence (1-5)')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('1 = Faible, 5 = Critique')
                .setRequired(false)
                .setMaxLength(1);

            modal.addComponents(
                new ActionRowBuilder().addComponents(subjectInput),
                new ActionRowBuilder().addComponents(descriptionInput),
                new ActionRowBuilder().addComponents(priorityInput)
            );

            await interaction.showModal(modal);

        } catch (error) {
            this.logger.error('Erreur lors de la cr√©ation du ticket:', error);
            await interaction.reply({
                content: '‚ùå Une erreur est survenue lors de la cr√©ation du ticket.',
                ephemeral: true
            });
        }
    }

    async handleModalSubmit(interaction) {
        try {
            const [, , type] = interaction.customId.split('_');
            const config = this.ticketTypes[type];
            const guild = interaction.guild;
            const user = interaction.user;

            const subject = interaction.fields.getTextInputValue('ticket_subject');
            const description = interaction.fields.getTextInputValue('ticket_description');
            const priority = interaction.fields.getTextInputValue('ticket_priority') || '3';

            await interaction.deferReply({ ephemeral: true });

            // Cr√©er ou r√©cup√©rer la cat√©gorie de tickets
            const ticketCategory = await this.ensureTicketCategory(guild);

            // Cr√©er le canal de ticket
            const ticketNumber = Date.now().toString().slice(-6);
            const ticketChannel = await guild.channels.create({
                name: `${config.emoji}„Éª${type}-${user.username}-${ticketNumber}`,
                type: ChannelType.GuildText,
                parent: ticketCategory.id,
                topic: `Ticket ${config.name} ‚Ä¢ ${subject} ‚Ä¢ Cr√©√© par ${user.tag}`,
                permissionOverwrites: [
                    {
                        id: guild.id,
                        deny: [PermissionFlagsBits.ViewChannel]
                    },
                    {
                        id: user.id,
                        allow: [
                            PermissionFlagsBits.ViewChannel,
                            PermissionFlagsBits.SendMessages,
                            PermissionFlagsBits.ReadMessageHistory,
                            PermissionFlagsBits.AttachFiles,
                            PermissionFlagsBits.EmbedLinks
                        ]
                    },
                    {
                        id: this.staffRoleId,
                        allow: [
                            PermissionFlagsBits.ViewChannel,
                            PermissionFlagsBits.SendMessages,
                            PermissionFlagsBits.ReadMessageHistory,
                            PermissionFlagsBits.ManageMessages,
                            PermissionFlagsBits.AttachFiles,
                            PermissionFlagsBits.EmbedLinks
                        ]
                    }
                ]
            });

            // Embed de bienvenue dans le ticket
            const welcomeEmbed = new EmbedBuilder()
                .setColor(config.color)
                .setTitle(`${config.emoji} **${config.name} - Ticket #${ticketNumber}**`)
                .setDescription(`
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ     **Bienvenue ${user.displayName}** üëã     ‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

**üìã Informations du Ticket :**
‚Ä¢ **Sujet :** ${subject}
‚Ä¢ **Type :** ${config.name}
‚Ä¢ **Num√©ro :** \`#${ticketNumber}\`
‚Ä¢ **Priorit√© :** ${this.getPriorityDisplay(priority)}
‚Ä¢ **Cr√©√© le :** <t:${Math.floor(Date.now() / 1000)}:F>
‚Ä¢ **Temps de r√©ponse estim√© :** \`${config.responseTime}\`

**üìù Description :**
\`\`\`
${description}
\`\`\`

**üéØ Prochaines √âtapes :**
1Ô∏è‚É£ Notre √©quipe a √©t√© notifi√©e automatiquement
2Ô∏è‚É£ Un membre du staff vous r√©pondra sous peu
3Ô∏è‚É£ Restez disponible pour d'√©ventuelles questions

**üí° En attendant, vous pouvez :**
‚Ä¢ Ajouter des captures d'√©cran si n√©cessaire
‚Ä¢ Pr√©ciser des d√©tails suppl√©mentaires
‚Ä¢ Utiliser les boutons ci-dessous`)
                .setThumbnail(user.displayAvatarURL({ dynamic: true }))
                .setFooter({ 
                    text: `Ticket ID: ${ticketNumber} ‚Ä¢ Notre √©quipe est notifi√©e`,
                    iconURL: guild.iconURL({ dynamic: true })
                })
                .setTimestamp();

            // Boutons d'actions pour le ticket
            const ticketActionsRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('ticket_close')
                        .setLabel('Fermer le Ticket')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('üîí'),
                    new ButtonBuilder()
                        .setCustomId('ticket_claim')
                        .setLabel('Prendre en Charge')
                        .setStyle(ButtonStyle.Success)
                        .setEmoji('‚úã'),
                    new ButtonBuilder()
                        .setCustomId('ticket_add_user')
                        .setLabel('Ajouter Utilisateur')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üë•'),
                    new ButtonBuilder()
                        .setCustomId('ticket_transcript')
                        .setLabel('Transcript')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('üìÑ')
                );

            await ticketChannel.send({
                content: `${user} | <@&${this.staffRoleId}>`,
                embeds: [welcomeEmbed],
                components: [ticketActionsRow]
            });

            // Notification priv√©e au staff
            await this.notifyStaff(guild, user, ticketChannel, config, subject, description, priority);

            await interaction.editReply({
                content: `‚úÖ **Ticket cr√©√© avec succ√®s !** ${ticketChannel}\nüéØ Notre √©quipe a √©t√© notifi√©e et vous r√©pondra dans **${config.responseTime}**.`
            });

            this.logger.info(`Ticket #${ticketNumber} cr√©√©: ${ticketChannel.name} par ${user.tag} (${type})`);

        } catch (error) {
            this.logger.error('Erreur lors du traitement du modal:', error);
            await interaction.editReply({
                content: '‚ùå Une erreur est survenue lors de la cr√©ation du ticket.'
            });
        }
    }

    async notifyStaff(guild, user, ticketChannel, config, subject, description, priority) {
        try {
            const staffRole = guild.roles.cache.get(this.staffRoleId);
            if (!staffRole) return;

            const staffMembers = staffRole.members;
            
            const notificationEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('üö® **NOUVEAU TICKET CR√â√â**')
                .setDescription(`
**Un nouveau ticket n√©cessite votre attention !**

**üë§ Utilisateur :** ${user} (${user.tag})
**üìã Sujet :** ${subject}
**üéØ Type :** ${config.emoji} ${config.name}
**‚ö° Priorit√© :** ${this.getPriorityDisplay(priority)}
**üìç Canal :** ${ticketChannel}
**‚è∞ Temps de r√©ponse attendu :** \`${config.responseTime}\`

**üìù Description :**
\`\`\`
${description.substring(0, 500)}${description.length > 500 ? '...' : ''}
\`\`\``)
                .setThumbnail(user.displayAvatarURL({ dynamic: true }))
                .setFooter({ text: 'Cliquez sur "Prendre en Charge" dans le ticket pour le traiter' })
                .setTimestamp();

            // Envoyer en MP √† chaque membre du staff
            for (const [id, member] of staffMembers) {
                try {
                    await member.send({ embeds: [notificationEmbed] });
                } catch (error) {
                    // Ignorer si on ne peut pas envoyer de MP
                }
            }

        } catch (error) {
            this.logger.error('Erreur lors de la notification du staff:', error);
        }
    }

    getPriorityDisplay(priority) {
        const priorities = {
            '1': 'üü¢ **Faible**',
            '2': 'üîµ **Normale**',
            '3': 'üü° **Moyenne**',
            '4': 'üü† **√âlev√©e**',
            '5': 'üî¥ **Critique**'
        };
        return priorities[priority] || 'üü° **Moyenne**';
    }

    // Gestionnaires pour les boutons d'actions rapides
    async handleQuickAction(interaction) {
        const action = interaction.customId;

        switch (action) {
            case 'ticket_faq':
                await this.showFAQ(interaction);
                break;
            case 'ticket_status':
                await this.showSupportStatus(interaction);
                break;
            case 'ticket_my_tickets':
                await this.showUserTickets(interaction);
                break;
            case 'ticket_contact_staff':
                await this.contactStaff(interaction);
                break;
        }
    }

    async showFAQ(interaction) {
        const faqEmbed = new EmbedBuilder()
            .setColor('#3498db')
            .setTitle('üìö **QUESTIONS FR√âQUEMMENT POS√âES**')
            .setDescription('**Voici les r√©ponses aux questions les plus courantes :**')
            .addFields(
                { 
                    name: '‚ùì **Comment cr√©er un ticket ?**', 
                    value: 'Cliquez sur l\'un des boutons ci-dessus selon votre type de demande, puis remplissez le formulaire.', 
                    inline: false 
                },
                { 
                    name: '‚è±Ô∏è **Combien de temps pour une r√©ponse ?**', 
                    value: 'Nos temps de r√©ponse varient de 30 minutes √† 24 heures selon la priorit√© de votre demande.', 
                    inline: false 
                },
                { 
                    name: 'üîÑ **Puis-je modifier mon ticket ?**', 
                    value: 'Oui, vous pouvez ajouter des informations √† tout moment dans votre canal de ticket.', 
                    inline: false 
                },
                { 
                    name: 'üë• **Puis-je ajouter quelqu\'un √† mon ticket ?**', 
                    value: 'Utilisez le bouton "Ajouter Utilisateur" dans votre ticket pour inviter quelqu\'un.', 
                    inline: false 
                },
                { 
                    name: 'üîí **Comment fermer mon ticket ?**', 
                    value: 'Utilisez le bouton "Fermer le Ticket" ou demandez √† un membre du staff.', 
                    inline: false 
                }
            )
            .setFooter({ text: 'Si votre question n\'est pas list√©e, cr√©ez un ticket !' })
            .setTimestamp();

        await interaction.reply({ embeds: [faqEmbed], ephemeral: true });
    }

    async showSupportStatus(interaction) {
        const guild = interaction.guild;
        const staffRole = guild.roles.cache.get(this.staffRoleId);
        const onlineStaff = staffRole ? staffRole.members.filter(member => member.presence?.status !== 'offline').size : 0;
        const totalStaff = staffRole ? staffRole.members.size : 0;

        const statusEmbed = new EmbedBuilder()
            .setColor('#2ecc71')
            .setTitle('üìä **STATUT DU SUPPORT EN TEMPS R√âEL**')
            .addFields(
                { name: 'üü¢ **Statut Global**', value: 'Tous les services op√©rationnels', inline: true },
                { name: 'üë• **√âquipe Disponible**', value: `${onlineStaff}/${totalStaff} agents en ligne`, inline: true },
                { name: 'üìà **Charge Actuelle**', value: 'Normale (< 70%)', inline: true },
                { name: '‚è±Ô∏è **Temps de R√©ponse Moyen**', value: '15 minutes', inline: true },
                { name: 'üéØ **Tickets Actifs**', value: `${guild.channels.cache.filter(c => c.name.includes('ticket')).size} tickets`, inline: true },
                { name: '‚úÖ **Disponibilit√©**', value: '24h/7j', inline: true }
            )
            .setFooter({ text: 'Derni√®re mise √† jour maintenant' })
            .setTimestamp();

        await interaction.reply({ embeds: [statusEmbed], ephemeral: true });
    }

    async showUserTickets(interaction) {
        const guild = interaction.guild;
        const userTickets = guild.channels.cache.filter(
            channel => channel.name.includes(interaction.user.username) && channel.name.includes('ticket')
        );
        
        const ticketsEmbed = new EmbedBuilder()
            .setColor('#9b59b6')
            .setTitle('üìã **VOS TICKETS**')
            .setDescription(userTickets.size > 0 ? 
                userTickets.map(ticket => 
                    `‚Ä¢ ${ticket} - Cr√©√© <t:${Math.floor(ticket.createdTimestamp / 1000)}:R>`
                ).join('\n') : 
                '**Vous n\'avez aucun ticket ouvert actuellement.**\n\n*Utilisez les boutons ci-dessus pour cr√©er un nouveau ticket.*'
            )
            .setFooter({ text: `Total: ${userTickets.size} ticket(s)` })
            .setTimestamp();

        await interaction.reply({ embeds: [ticketsEmbed], ephemeral: true });
    }

    async contactStaff(interaction) {
        const contactEmbed = new EmbedBuilder()
            .setColor('#e74c3c')
            .setTitle('üìû **CONTACT DIRECT AVEC LE STAFF**')
            .setDescription(`
**Pour un contact direct avec notre √©quipe :**

**üí¨ Discord :**
‚Ä¢ Mentionnez <@&${this.staffRoleId}> dans votre ticket
‚Ä¢ Utilisez les canaux publics pour les questions g√©n√©rales

**‚ö° Urgences :**
‚Ä¢ Cr√©ez un ticket de type "Signalement" 
‚Ä¢ Temps de r√©ponse garanti : 30 minutes - 1 heure

**üìß Autres moyens :**
‚Ä¢ Les tickets restent le moyen le plus efficace
‚Ä¢ Toutes les demandes sont trait√©es par ordre de priorit√©

**üéØ Conseil :** Cr√©ez un ticket pour un suivi optimal de votre demande !`)
            .setFooter({ text: 'Notre √©quipe est l√† pour vous aider !' })
            .setTimestamp();

        await interaction.reply({ embeds: [contactEmbed], ephemeral: true });
    }

    // Gestionnaires pour les actions dans les tickets
    async handleTicketAction(interaction) {
        const action = interaction.customId;

        switch (action) {
            case 'ticket_close':
                await this.closeTicket(interaction);
                break;
            case 'ticket_claim':
                await this.claimTicket(interaction);
                break;
            case 'ticket_add_user':
                await this.addUserToTicket(interaction);
                break;
            case 'ticket_transcript':
                await this.createTranscript(interaction);
                break;
        }
    }

    async closeTicket(interaction) {
        try {
            const channel = interaction.channel;
            
            const confirmEmbed = new EmbedBuilder()
                .setColor('#e74c3c')
                .setTitle('üîí **FERMETURE DU TICKET**')
                .setDescription(`
**√ätes-vous s√ªr de vouloir fermer ce ticket ?**

Cette action est **irr√©versible** et le canal sera supprim√© dans 10 secondes apr√®s confirmation.

**üìã R√©sum√© du ticket :**
‚Ä¢ **Canal :** ${channel.name}
‚Ä¢ **Cr√©√© le :** <t:${Math.floor(channel.createdTimestamp / 1000)}:F>
‚Ä¢ **Dur√©e :** <t:${Math.floor(channel.createdTimestamp / 1000)}:R>`)
                .setFooter({ text: 'Cliquez sur "Confirmer" pour fermer d√©finitivement' });

            const confirmRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_close')
                        .setLabel('Confirmer la Fermeture')
                        .setStyle(ButtonStyle.Danger)
                        .setEmoji('‚úÖ'),
                    new ButtonBuilder()
                        .setCustomId('cancel_close')
                        .setLabel('Annuler')
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('‚ùå')
                );

            await interaction.reply({
                embeds: [confirmEmbed],
                components: [confirmRow],
                ephemeral: true
            });

        } catch (error) {
            this.logger.error('Erreur lors de la fermeture du ticket:', error);
        }
    }

    async claimTicket(interaction) {
        try {
            const member = interaction.member;
            const restrictedRoleId = '1386990308679483393';

            // V√©rifier si l'utilisateur a le r√¥le restreint
            if (member.roles.cache.has(restrictedRoleId)) {
                return await interaction.reply({
                    content: '‚ùå **Acc√®s refus√© !**\n\nVous n\'avez pas les permissions n√©cessaires pour prendre en charge un ticket.\n\nüí° Cette action est r√©serv√©e √† l\'√©quipe de mod√©ration.',
                    ephemeral: true
                });
            }

            // V√©rifier si l'utilisateur a le r√¥le staff
            if (!member.roles.cache.has(this.staffRoleId)) {
                return await interaction.reply({
                    content: '‚ùå **Permissions insuffisantes !**\n\nSeuls les membres du staff peuvent prendre en charge un ticket.',
                    ephemeral: true
                });
            }

            const channel = interaction.channel;
            const staff = interaction.user;

            const claimEmbed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('‚úã **TICKET PRIS EN CHARGE**')
                .setDescription(`
**${staff} a pris ce ticket en charge !**

**üìã Informations :**
‚Ä¢ **Agent assign√© :** ${staff}
‚Ä¢ **Pris en charge le :** <t:${Math.floor(Date.now() / 1000)}:F>
‚Ä¢ **Statut :** üü¢ En cours de traitement

**üë§ ${channel.topic?.split('‚Ä¢')[2]?.trim() || 'Utilisateur'} :** Votre demande est maintenant entre de bonnes mains !`)
                .setThumbnail(staff.displayAvatarURL({ dynamic: true }))
                .setFooter({ text: 'Ticket assign√© avec succ√®s' })
                .setTimestamp();

            await interaction.reply({ embeds: [claimEmbed] });

        } catch (error) {
            this.logger.error('Erreur lors de la prise en charge:', error);
        }
    }

    async addUserToTicket(interaction) {
        // Modal pour ajouter un utilisateur
        const modal = new ModalBuilder()
            .setCustomId('add_user_modal')
            .setTitle('üë• Ajouter un Utilisateur');

        const userInput = new TextInputBuilder()
            .setCustomId('user_id')
            .setLabel('ID ou mention de l\'utilisateur')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('123456789012345678 ou @utilisateur')
            .setRequired(true);

        modal.addComponents(new ActionRowBuilder().addComponents(userInput));
        await interaction.showModal(modal);
    }

    async createTranscript(interaction) {
        try {
            await interaction.deferReply({ ephemeral: true });

            const channel = interaction.channel;
            const messages = await channel.messages.fetch({ limit: 100 });
            
            let transcript = `TRANSCRIPT DU TICKET - ${channel.name}\n`;
            transcript += `G√©n√©r√© le: ${new Date().toLocaleString('fr-FR')}\n`;
            transcript += `Canal: ${channel.name}\n`;
            transcript += `Cr√©√© le: ${new Date(channel.createdTimestamp).toLocaleString('fr-FR')}\n\n`;
            transcript += '='.repeat(50) + '\n\n';

            messages.reverse().forEach(msg => {
                transcript += `[${new Date(msg.createdTimestamp).toLocaleString('fr-FR')}] ${msg.author.tag}: ${msg.content}\n`;
                if (msg.embeds.length > 0) {
                    transcript += `  [EMBED: ${msg.embeds[0].title || 'Sans titre'}]\n`;
                }
                if (msg.attachments.size > 0) {
                    transcript += `  [FICHIERS: ${msg.attachments.map(a => a.name).join(', ')}]\n`;
                }
                transcript += '\n';
            });

            // Cr√©er un embed avec le transcript
            const transcriptEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle('üìÑ **TRANSCRIPT G√âN√âR√â**')
                .setDescription(`
**Transcript du ticket g√©n√©r√© avec succ√®s !**

**üìã Informations :**
‚Ä¢ **Canal :** ${channel.name}
‚Ä¢ **Messages r√©cup√©r√©s :** ${messages.size}
‚Ä¢ **G√©n√©r√© le :** <t:${Math.floor(Date.now() / 1000)}:F>
‚Ä¢ **G√©n√©r√© par :** ${interaction.user}

**üìé Le transcript complet a √©t√© envoy√© en message priv√©.**`)
                .setFooter({ text: 'Transcript sauvegard√©' })
                .setTimestamp();

            // Envoyer le transcript en MP
            try {
                await interaction.user.send({
                    content: `**Transcript du ticket ${channel.name}**`,
                    files: [{
                        attachment: Buffer.from(transcript, 'utf8'),
                        name: `transcript-${channel.name}-${Date.now()}.txt`
                    }]
                });

                await interaction.editReply({ embeds: [transcriptEmbed] });
            } catch (error) {
                await interaction.editReply({
                    content: '‚ùå Impossible d\'envoyer le transcript en MP. V√©rifiez vos param√®tres de confidentialit√©.'
                });
            }

        } catch (error) {
            this.logger.error('Erreur lors de la cr√©ation du transcript:', error);
            await interaction.editReply({
                content: '‚ùå Une erreur est survenue lors de la g√©n√©ration du transcript.'
            });
        }
    }

    async handleAddUserModal(interaction) {
        try {
            const userId = interaction.fields.getTextInputValue('user_id').replace(/[<@!>]/g, '');
            const channel = interaction.channel;
            const guild = interaction.guild;

            const user = await guild.members.fetch(userId).catch(() => null);
            if (!user) {
                return await interaction.reply({
                    content: '‚ùå Utilisateur introuvable. V√©rifiez l\'ID ou la mention.',
                    ephemeral: true
                });
            }

            // Ajouter les permissions √† l'utilisateur
            await channel.permissionOverwrites.create(user.id, {
                ViewChannel: true,
                SendMessages: true,
                ReadMessageHistory: true,
                AttachFiles: true,
                EmbedLinks: true
            });

            const addUserEmbed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('üë• **UTILISATEUR AJOUT√â**')
                .setDescription(`
**${user} a √©t√© ajout√© au ticket !**

**üìã Informations :**
‚Ä¢ **Utilisateur ajout√© :** ${user} (${user.user.tag})
‚Ä¢ **Ajout√© par :** ${interaction.user}
‚Ä¢ **Ajout√© le :** <t:${Math.floor(Date.now() / 1000)}:F>
‚Ä¢ **Permissions accord√©es :** Lecture, √©criture, fichiers

**üëã ${user}, bienvenue dans ce ticket !**`)
                .setThumbnail(user.user.displayAvatarURL({ dynamic: true }))
                .setFooter({ text: 'Utilisateur ajout√© avec succ√®s' })
                .setTimestamp();

            await interaction.reply({ embeds: [addUserEmbed] });

        } catch (error) {
            this.logger.error('Erreur lors de l\'ajout d\'utilisateur:', error);
            await interaction.reply({
                content: '‚ùå Une erreur est survenue lors de l\'ajout de l\'utilisateur.',
                ephemeral: true
            });
        }
    }

    async handleConfirmClose(interaction) {
        try {
            const channel = interaction.channel;
            
            const closingEmbed = new EmbedBuilder()
                .setColor('#e74c3c')
                .setTitle('üîí **TICKET EN COURS DE FERMETURE**')
                .setDescription(`
**Ce ticket va √™tre ferm√© dans 10 secondes...**

**üìã R√©sum√© final :**
‚Ä¢ **Ferm√© par :** ${interaction.user}
‚Ä¢ **Ferm√© le :** <t:${Math.floor(Date.now() / 1000)}:F>
‚Ä¢ **Dur√©e totale :** <t:${Math.floor(channel.createdTimestamp / 1000)}:R>

**üíæ Pensez √† sauvegarder les informations importantes !**

*Merci d'avoir utilis√© notre syst√®me de support.*`)
                .setFooter({ text: 'Fermeture automatique dans 10 secondes' })
                .setTimestamp();

            await interaction.update({
                embeds: [closingEmbed],
                components: []
            });

            // Supprimer le canal apr√®s 10 secondes
            setTimeout(async () => {
                try {
                    await channel.delete('Ticket ferm√©');
                } catch (error) {
                    this.logger.error('Erreur lors de la suppression du canal:', error);
                }
            }, 10000);

        } catch (error) {
            this.logger.error('Erreur lors de la fermeture confirm√©e:', error);
        }
    }

    async handleCancelClose(interaction) {
        const cancelEmbed = new EmbedBuilder()
            .setColor('#2ecc71')
            .setTitle('‚úÖ **FERMETURE ANNUL√âE**')
            .setDescription(`
**La fermeture du ticket a √©t√© annul√©e.**

Le ticket reste ouvert et vous pouvez continuer √† l'utiliser normalement.

**üéØ Actions disponibles :**
‚Ä¢ Continuer la conversation
‚Ä¢ Utiliser les boutons d'actions
‚Ä¢ Fermer plus tard si n√©cessaire`)
            .setFooter({ text: 'Ticket toujours actif' })
            .setTimestamp();

        await interaction.update({
            embeds: [cancelEmbed],
            components: []
        });
    }

    // M√©thode pour cr√©er ou r√©cup√©rer la cat√©gorie de tickets
    async ensureTicketCategory(guild) {
        try {
            // Chercher une cat√©gorie existante avec le nom "üé´ Tickets"
            let ticketCategory = guild.channels.cache.find(
                channel => channel.type === ChannelType.GuildCategory && 
                          (channel.name.includes('Tickets') || channel.name.includes('üé´'))
            );

            // Si la cat√©gorie n'existe pas, la cr√©er
            if (!ticketCategory) {
                ticketCategory = await guild.channels.create({
                    name: 'üé´ Tickets',
                    type: ChannelType.GuildCategory,
                    permissionOverwrites: [
                        {
                            id: guild.id,
                            deny: [PermissionFlagsBits.ViewChannel]
                        },
                        {
                            id: this.staffRoleId,
                            allow: [
                                PermissionFlagsBits.ViewChannel,
                                PermissionFlagsBits.ManageChannels,
                                PermissionFlagsBits.ManageMessages
                            ]
                        }
                    ]
                });

                this.logger.success(`Cat√©gorie de tickets cr√©√©e: ${ticketCategory.name}`);
            }

            // Mettre √† jour l'ID de la cat√©gorie
            this.ticketCategoryId = ticketCategory.id;
            
            return ticketCategory;

        } catch (error) {
            this.logger.error('Erreur lors de la cr√©ation/r√©cup√©ration de la cat√©gorie de tickets:', error);
            throw error;
        }
    }

    // M√©thode pour nettoyer les tickets ferm√©s (optionnel)
    async cleanupClosedTickets(guild) {
        try {
            const ticketCategory = guild.channels.cache.get(this.ticketCategoryId);
            if (!ticketCategory) return;

            const ticketChannels = ticketCategory.children.cache.filter(
                channel => channel.type === ChannelType.GuildText && 
                          channel.name.includes('ticket')
            );

            // Supprimer les tickets inactifs depuis plus de 7 jours
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            
            for (const [id, channel] of ticketChannels) {
                try {
                    const messages = await channel.messages.fetch({ limit: 1 });
                    const lastMessage = messages.first();
                    
                    if (!lastMessage || lastMessage.createdTimestamp < sevenDaysAgo) {
                        await channel.delete('Nettoyage automatique - ticket inactif');
                        this.logger.info(`Ticket inactif supprim√©: ${channel.name}`);
                    }
                } catch (error) {
                    // Ignorer les erreurs de suppression
                }
            }

        } catch (error) {
            this.logger.error('Erreur lors du nettoyage des tickets:', error);
        }
    }

    // M√©thode pour obtenir les statistiques des tickets
    async getTicketStats(guild) {
        try {
            const ticketCategory = guild.channels.cache.get(this.ticketCategoryId);
            if (!ticketCategory) return null;

            const ticketChannels = ticketCategory.children.cache.filter(
                channel => channel.type === ChannelType.GuildText && 
                          channel.name.includes('ticket')
            );

            const stats = {
                total: ticketChannels.size,
                byType: {},
                recent: 0
            };

            // Compter par type
            Object.keys(this.ticketTypes).forEach(type => {
                stats.byType[type] = ticketChannels.filter(
                    channel => channel.name.includes(type)
                ).size;
            });

            // Compter les tickets r√©cents (derni√®res 24h)
            const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
            stats.recent = ticketChannels.filter(
                channel => channel.createdTimestamp > oneDayAgo
            ).size;

            return stats;

        } catch (error) {
            this.logger.error('Erreur lors du calcul des statistiques:', error);
            return null;
        }
    }
}

export default TicketManager;
