import { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, StringSelectMenuBuilder, ChannelType } from 'discord.js';
import AccessRestriction from '../utils/AccessRestriction.js';

export default class ModerationButtonHandler {
    constructor(client) {
        this.client = client;
        this.moderationManager = client.moderationManager;
        this.logger = client.logger;
        this.accessRestriction = new AccessRestriction();
    }

    async handleModerationButton(interaction) {
        const customId = interaction.customId;
        
        try {
            // === V√âRIFICATION D'ACC√àS GLOBALE ===
            const hasAccess = await this.accessRestriction.checkAccess(interaction);
            if (!hasAccess) {
                return; // Acc√®s refus√©, message d√©j√† envoy√©
            }

            if (customId.startsWith('mod_warn_')) {
                await this.handleWarnButton(interaction);
            } else if (customId.startsWith('mod_mute_')) {
                await this.handleMuteButton(interaction);
            } else if (customId.startsWith('mod_kick_')) {
                await this.handleKickButton(interaction);
            } else if (customId.startsWith('mod_ban_')) {
                await this.handleBanButton(interaction);
            } else if (customId.startsWith('mod_unban_')) {
                await this.handleUnbanButton(interaction);
            } else if (customId.startsWith('mod_unmute_')) {
                await this.handleUnmuteButton(interaction);
            } else if (customId.startsWith('mod_history_')) {
                await this.handleHistoryButton(interaction);
            } else if (customId === 'mod_stats') {
                await this.handleStatsButton(interaction);
            } else if (customId === 'mod_config') {
                await this.handleConfigButton(interaction);
            } else if (customId === 'mod_refresh_panel') {
                await this.handleRefreshPanel(interaction);
            } else if (customId.startsWith('mod_clear_warnings')) {
                await this.handleClearWarnings(interaction);
            } else if (customId === 'mod_quick_actions') {
                await this.handleQuickActions(interaction);
            } else if (customId.startsWith('quick_')) {
                await this.handleQuickActionButton(interaction);
            } else if (customId.startsWith('history_')) {
                await this.handleHistoryNavigation(interaction);
            }
            
        } catch (error) {
            this.logger.error('Erreur dans ModerationButtonHandler:', error);
            
            const errorMsg = {
                content: '‚ùå Une erreur est survenue lors du traitement de votre demande.',
                ephemeral: true
            };

            if (interaction.deferred || interaction.replied) {
                await interaction.editReply(errorMsg);
            } else {
                await interaction.reply(errorMsg);
            }
        }
    }

    async handleModerationSelect(interaction) {
        const customId = interaction.customId;
        const value = interaction.values[0];
        
        try {
            // === V√âRIFICATION D'ACC√àS GLOBALE ===
            const hasAccess = await this.accessRestriction.checkAccess(interaction);
            if (!hasAccess) {
                return; // Acc√®s refus√©, message d√©j√† envoy√©
            }

            if (customId === 'mod_config_select') {
                await this.handleConfigSelect(interaction, value);
            } else if (customId === 'mod_user_select') {
                await this.handleUserSelect(interaction, value);
            } else if (customId === 'mod_duration_select') {
                await this.handleDurationSelect(interaction, value);
            }
            
        } catch (error) {
            this.logger.error('Erreur dans handleModerationSelect:', error);
            
            await interaction.reply({
                content: '‚ùå Une erreur est survenue lors du traitement de votre s√©lection.',
                ephemeral: true
            });
        }
    }

    async handleModerationModal(interaction) {
        const customId = interaction.customId;
        
        try {
            // === V√âRIFICATION D'ACC√àS GLOBALE ===
            const hasAccess = await this.accessRestriction.checkAccess(interaction);
            if (!hasAccess) {
                return; // Acc√®s refus√©, message d√©j√† envoy√©
            }

            if (customId === 'mod_warn_modal') {
                await this.handleWarnModal(interaction);
            } else if (customId === 'mod_mute_modal') {
                await this.handleMuteModal(interaction);
            } else if (customId === 'mod_kick_modal') {
                await this.handleKickModal(interaction);
            } else if (customId === 'mod_ban_modal') {
                await this.handleBanModal(interaction);
            } else if (customId === 'mod_unban_modal') {
                await this.handleUnbanModal(interaction);
            } else if (customId === 'mod_unmute_modal') {
                await this.handleUnmuteModal(interaction);
            } else if (customId === 'mod_set_log_channel') {
                await this.handleSetLogChannel(interaction);
            } else if (customId === 'mod_history_modal') {
                await this.handleHistoryModal(interaction);
            } else if (customId === 'quick_warn_modal') {
                await this.handleQuickWarnModal(interaction);
            } else if (customId === 'quick_mute_modal') {
                await this.handleQuickMuteModal(interaction);
            } else if (customId === 'quick_user_info_modal') {
                await this.handleQuickUserInfoModal(interaction);
            } else if (customId === 'quick_clear_warns_modal') {
                await this.handleQuickClearWarnsModal(interaction);
            }
            
        } catch (error) {
            this.logger.error('Erreur dans handleModerationModal:', error);
            
            await interaction.reply({
                content: '‚ùå Une erreur est survenue lors du traitement du modal.',
                ephemeral: true
            });
        }
    }

    // ==================== BOUTONS ====================

    async handleWarnButton(interaction) {
        const modal = new ModalBuilder()
            .setCustomId('mod_warn_modal')
            .setTitle('‚ö†Ô∏è Avertir un utilisateur');

        const userInput = new TextInputBuilder()
            .setCustomId('user_id')
            .setLabel('ID ou mention de l\'utilisateur')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('123456789012345678 ou @utilisateur')
            .setRequired(true);

        const reasonInput = new TextInputBuilder()
            .setCustomId('reason')
            .setLabel('Raison de l\'avertissement')
            .setStyle(TextInputStyle.Paragraph)
            .setPlaceholder('D√©crivez la raison de cet avertissement...')
            .setRequired(true)
            .setMaxLength(500);

        const firstRow = new ActionRowBuilder().addComponents(userInput);
        const secondRow = new ActionRowBuilder().addComponents(reasonInput);

        modal.addComponents(firstRow, secondRow);
        await interaction.showModal(modal);
    }

    async handleMuteButton(interaction) {
        const modal = new ModalBuilder()
            .setCustomId('mod_mute_modal')
            .setTitle('üîá Muter un utilisateur');

        const userInput = new TextInputBuilder()
            .setCustomId('user_id')
            .setLabel('ID ou mention de l\'utilisateur')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('123456789012345678 ou @utilisateur')
            .setRequired(true);

        const durationInput = new TextInputBuilder()
            .setCustomId('duration')
            .setLabel('Dur√©e (5m, 1h, 1d, 7d)')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('1h')
            .setRequired(false);

        const reasonInput = new TextInputBuilder()
            .setCustomId('reason')
            .setLabel('Raison du mute')
            .setStyle(TextInputStyle.Paragraph)
            .setPlaceholder('D√©crivez la raison de ce mute...')
            .setRequired(true)
            .setMaxLength(500);

        const firstRow = new ActionRowBuilder().addComponents(userInput);
        const secondRow = new ActionRowBuilder().addComponents(durationInput);
        const thirdRow = new ActionRowBuilder().addComponents(reasonInput);

        modal.addComponents(firstRow, secondRow, thirdRow);
        await interaction.showModal(modal);
    }

    async handleKickButton(interaction) {
        const modal = new ModalBuilder()
            .setCustomId('mod_kick_modal')
            .setTitle('üë¢ Expulser un utilisateur');

        const userInput = new TextInputBuilder()
            .setCustomId('user_id')
            .setLabel('ID ou mention de l\'utilisateur')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('123456789012345678 ou @utilisateur')
            .setRequired(true);

        const reasonInput = new TextInputBuilder()
            .setCustomId('reason')
            .setLabel('Raison de l\'expulsion')
            .setStyle(TextInputStyle.Paragraph)
            .setPlaceholder('D√©crivez la raison de cette expulsion...')
            .setRequired(true)
            .setMaxLength(500);

        const firstRow = new ActionRowBuilder().addComponents(userInput);
        const secondRow = new ActionRowBuilder().addComponents(reasonInput);

        modal.addComponents(firstRow, secondRow);
        await interaction.showModal(modal);
    }

    async handleBanButton(interaction) {
        const modal = new ModalBuilder()
            .setCustomId('mod_ban_modal')
            .setTitle('üî® Bannir un utilisateur');

        const userInput = new TextInputBuilder()
            .setCustomId('user_id')
            .setLabel('ID ou mention de l\'utilisateur')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('123456789012345678 ou @utilisateur')
            .setRequired(true);

        const durationInput = new TextInputBuilder()
            .setCustomId('duration')
            .setLabel('Dur√©e (vide = permanent)')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('7d (optionnel)')
            .setRequired(false);

        const reasonInput = new TextInputBuilder()
            .setCustomId('reason')
            .setLabel('Raison du bannissement')
            .setStyle(TextInputStyle.Paragraph)
            .setPlaceholder('D√©crivez la raison de ce bannissement...')
            .setRequired(true)
            .setMaxLength(500);

        const firstRow = new ActionRowBuilder().addComponents(userInput);
        const secondRow = new ActionRowBuilder().addComponents(durationInput);
        const thirdRow = new ActionRowBuilder().addComponents(reasonInput);

        modal.addComponents(firstRow, secondRow, thirdRow);
        await interaction.showModal(modal);
    }

    // ==================== HISTORIQUE AM√âLIOR√â ====================
    async handleHistoryButton(interaction) {
        const customId = interaction.customId;
        
        // V√©rifier si c'est un bouton d'historique sp√©cifique avec un ID utilisateur
        if (customId.includes('_full_')) {
            const userId = customId.split('_full_')[1];
            await this.handleFullHistory(interaction, userId);
            return;
        }
        
        if (customId.includes('_export_')) {
            const userId = customId.split('_export_')[1];
            await this.handleExportHistory(interaction, userId);
            return;
        }
        
        if (customId.includes('_quick_action_')) {
            const userId = customId.split('_quick_action_')[1];
            await this.handleQuickActionsForUser(interaction, userId);
            return;
        }

        // Si c'est le bouton g√©n√©ral, afficher le modal
        const modal = new ModalBuilder()
            .setCustomId('mod_history_modal')
            .setTitle('üìã Consulter l\'historique d√©taill√©');

        const userInput = new TextInputBuilder()
            .setCustomId('user_id')
            .setLabel('ID ou mention de l\'utilisateur')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('123456789012345678 ou @utilisateur')
            .setRequired(true);

        const detailedInput = new TextInputBuilder()
            .setCustomId('detailed')
            .setLabel('Affichage d√©taill√© ? (oui/non)')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('oui pour plus de d√©tails')
            .setRequired(false);

        const firstRow = new ActionRowBuilder().addComponents(userInput);
        const secondRow = new ActionRowBuilder().addComponents(detailedInput);
        
        modal.addComponents(firstRow, secondRow);
        await interaction.showModal(modal);
    }

    async handleFullHistory(interaction, userId) {
        await interaction.deferReply({ ephemeral: true });

        try {
            const targetUser = await this.resolveUser(userId);
            if (!targetUser) {
                return await interaction.editReply({
                    content: '‚ùå Utilisateur non trouv√©.'
                });
            }

            const history = await this.moderationManager.getUserHistory(targetUser.id);
            const warnings = await this.moderationManager.getUserWarnings(targetUser.id);

            if (history.length === 0 && warnings.length === 0) {
                const embed = new EmbedBuilder()
                    .setTitle('üìã Historique complet')
                    .setDescription(`**${targetUser.tag}** n'a aucun ant√©c√©dent. ‚úÖ`)
                    .setColor('#00ff00');
                
                return await interaction.editReply({ embeds: [embed] });
            }

            // G√©n√©rer un rapport complet avec pagination
            const fullHistoryEmbeds = await this.generateFullHistoryEmbeds(targetUser, history, warnings);
            
            // Syst√®me de pagination
            let currentPage = 0;
            const totalPages = fullHistoryEmbeds.length;

            const navigationRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`history_prev_${userId}`)
                        .setLabel('‚óÄÔ∏è Pr√©c√©dent')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`history_page_${userId}`)
                        .setLabel(`Page ${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`history_next_${userId}`)
                        .setLabel('Suivant ‚ñ∂Ô∏è')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId(`mod_export_history_${userId}`)
                        .setLabel('üìÅ Exporter')
                        .setStyle(ButtonStyle.Success)
                );

            await interaction.editReply({
                embeds: [fullHistoryEmbeds[currentPage]],
                components: [navigationRow]
            });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur: ${error.message}`
            });
        }
    }

    async handleExportHistory(interaction, userId) {
        await interaction.deferReply({ ephemeral: true });

        try {
            const targetUser = await this.resolveUser(userId);
            if (!targetUser) {
                return await interaction.editReply({
                    content: '‚ùå Utilisateur non trouv√©.'
                });
            }

            const history = await this.moderationManager.getUserHistory(targetUser.id);
            const warnings = await this.moderationManager.getUserWarnings(targetUser.id);

            // G√©n√©rer un rapport d√©taill√©
            const report = this.generateDetailedReport(targetUser, history, warnings);
            
            // Cr√©er un fichier
            const buffer = Buffer.from(report, 'utf-8');
            
            const embed = new EmbedBuilder()
                .setTitle('üìÅ Export de l\'historique')
                .setDescription(`Historique complet de **${targetUser.tag}** export√© avec succ√®s.`)
                .addFields(
                    { name: 'üìä Actions totales', value: history.length.toString(), inline: true },
                    { name: '‚ö†Ô∏è Avertissements', value: warnings.length.toString(), inline: true },
                    { name: 'üìÖ G√©n√©r√© le', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true }
                )
                .setColor('#00ff00')
                .setTimestamp();

            await interaction.editReply({
                embeds: [embed],
                files: [{
                    attachment: buffer,
                    name: `historique-${targetUser.tag.replace(/\s+/g, '-')}-${Date.now()}.txt`
                }]
            });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur lors de l'export: ${error.message}`
            });
        }
    }

    async handleQuickActionsForUser(interaction, userId) {
        const targetUser = await this.resolveUser(userId);
        if (!targetUser) {
            return await interaction.reply({
                content: '‚ùå Utilisateur non trouv√©.',
                ephemeral: true
            });
        }

        const embed = new EmbedBuilder()
            .setTitle(`‚ö° Actions rapides pour ${targetUser.tag}`)
            .setDescription('S√©lectionnez une action √† effectuer rapidement')
            .setThumbnail(targetUser.displayAvatarURL())
            .setColor('#ff6b35');

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`quick_warn_user_${userId}`)
                    .setLabel('‚ö†Ô∏è Avertir')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId(`quick_mute_user_${userId}`)
                    .setLabel('üîá Mute 1h')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`quick_kick_user_${userId}`)
                    .setLabel('üë¢ Kick')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId(`mod_clear_warnings_${userId}`)
                    .setLabel('üßπ Clear Warns')
                    .setStyle(ButtonStyle.Success)
            );

        await interaction.reply({
            embeds: [embed],
            components: [actionRow],
            ephemeral: true
        });
    }

    async handleHistoryNavigation(interaction, userId) {
        const customId = interaction.customId;
        
        if (customId.startsWith('history_prev_') || customId.startsWith('history_next_')) {
            // Logique de navigation entre pages
            await interaction.deferUpdate();
            // Impl√©mentation de la pagination ici
        }
    }

    async handleHistoryModal(interaction) {
        await interaction.deferReply({ ephemeral: true });

        try {
            const userInput = interaction.fields.getTextInputValue('user_id');
            const detailedInput = interaction.fields.getTextInputValue('detailed') || '';
            const detailed = detailedInput.toLowerCase().includes('oui');

            const targetUser = await this.resolveUser(userInput);
            if (!targetUser) {
                return await interaction.editReply({
                    content: '‚ùå Utilisateur non trouv√©. V√©rifiez l\'ID ou la mention.'
                });
            }

            // Simuler la commande /moderation history
            const history = await this.moderationManager.getUserHistory(targetUser.id);
            const warnings = await this.moderationManager.getUserWarnings(targetUser.id);
            const member = await interaction.guild.members.fetch(targetUser.id).catch(() => null);

            if (history.length === 0 && warnings.length === 0) {
                const embed = new EmbedBuilder()
                    .setTitle('üìã Historique de mod√©ration')
                    .setDescription(`**${targetUser.tag}** n'a aucun ant√©c√©dent de mod√©ration. ‚úÖ`)
                    .addFields(
                        { name: 'üéØ Statut', value: 'Membre exemplaire', inline: true },
                        { name: 'üìÖ Derni√®re v√©rification', value: `<t:${Math.floor(Date.now() / 1000)}:R>`, inline: true },
                        { name: 'üèÜ R√©putation', value: '100% Propre', inline: true }
                    )
                    .setColor('#00ff00')
                    .setTimestamp()
                    .setThumbnail(targetUser.displayAvatarURL());

                return await interaction.editReply({ embeds: [embed] });
            }

            // G√©n√©rer l'historique d√©taill√©
            const embeds = await this.generateHistoryEmbeds(targetUser, history, warnings, member, detailed);
            
            // Boutons d'actions
            const actionRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`mod_history_full_${targetUser.id}`)
                        .setLabel('üìÑ Historique complet')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(detailed),
                    new ButtonBuilder()
                        .setCustomId(`mod_clear_warnings_${targetUser.id}`)
                        .setLabel('üßπ Effacer les avertissements')
                        .setStyle(ButtonStyle.Danger)
                        .setDisabled(warnings.filter(w => w.active).length === 0),
                    new ButtonBuilder()
                        .setCustomId(`mod_quick_action_${targetUser.id}`)
                        .setLabel('‚ö° Actions rapides')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId(`mod_export_history_${targetUser.id}`)
                        .setLabel('üìÅ Exporter')
                        .setStyle(ButtonStyle.Secondary)
                );

            await interaction.editReply({ 
                embeds: embeds,
                components: [actionRow]
            });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur: ${error.message}`
            });
        }
    }

    // ==================== G√âN√âRATEURS D'EMBEDS ====================
    async generateHistoryEmbeds(targetUser, history, warnings, member, detailed) {
        const embeds = [];

        // Embed principal
        const mainEmbed = new EmbedBuilder()
            .setTitle('üìã **HISTORIQUE DE MOD√âRATION**')
            .setDescription(`**Profil de ${targetUser.tag}**`)
            .addFields(
                { name: 'üë§ Utilisateur', value: `${targetUser.tag}`, inline: true },
                { name: 'üÜî ID Discord', value: `\`${targetUser.id}\``, inline: true },
                { name: 'üìÖ Compte cr√©√©', value: `<t:${Math.floor(targetUser.createdTimestamp / 1000)}:R>`, inline: true }
            )
            .setColor('#3498db')
            .setThumbnail(targetUser.displayAvatarURL())
            .setTimestamp();

        if (member) {
            mainEmbed.addFields(
                { name: 'üì• Rejoint le serveur', value: `<t:${Math.floor(member.joinedTimestamp / 1000)}:R>`, inline: true },
                { name: 'üëë R√¥les', value: member.roles.cache.size > 1 ? `${member.roles.cache.size - 1} r√¥les` : 'Aucun r√¥le', inline: true }
            );
        }

        embeds.push(mainEmbed);

        // Statistiques
        const actionCounts = {
            warn: history.filter(h => h.type === 'warn').length,
            mute: history.filter(h => h.type === 'mute').length,
            kick: history.filter(h => h.type === 'kick').length,
            ban: history.filter(h => h.type === 'ban').length
        };

        const statsEmbed = new EmbedBuilder()
            .setTitle('üìä **STATISTIQUES**')
            .addFields(
                { name: '‚ö†Ô∏è Avertissements', value: `${actionCounts.warn} total\n${warnings.filter(w => w.active).length} actifs`, inline: true },
                { name: 'üîá Mutes', value: `${actionCounts.mute} total`, inline: true },
                { name: 'üë¢ Expulsions', value: `${actionCounts.kick} total`, inline: true }
            )
            .setColor('#9b59b6');

        embeds.push(statsEmbed);

        return embeds;
    }

    async generateFullHistoryEmbeds(targetUser, history, warnings) {
        const embeds = [];
        const itemsPerPage = 5;
        const totalItems = history.length + warnings.length;
        const totalPages = Math.ceil(totalItems / itemsPerPage);

        // Combiner et trier par date
        const allItems = [
            ...history.map(h => ({ ...h, itemType: 'history' })),
            ...warnings.map(w => ({ ...w, itemType: 'warning' }))
        ].sort((a, b) => b.timestamp - a.timestamp);

        for (let page = 0; page < totalPages; page++) {
            const startIndex = page * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageItems = allItems.slice(startIndex, endIndex);

            const embed = new EmbedBuilder()
                .setTitle(`üìã Historique complet - Page ${page + 1}/${totalPages}`)
                .setDescription(`**${targetUser.tag}** - ${totalItems} √©l√©ments au total`)
                .setColor('#3498db')
                .setTimestamp();

            pageItems.forEach((item, index) => {
                const globalIndex = startIndex + index + 1;
                const date = `<t:${Math.floor(item.timestamp / 1000)}:R>`;
                
                if (item.itemType === 'history') {
                    const action = this.getActionEmoji(item.type) + ' ' + item.type.toUpperCase();
                    const reason = item.data?.reason || 'Aucune raison';
                    embed.addFields({
                        name: `${globalIndex}. ${action} ${date}`,
                        value: `üìù **Raison:** ${reason}\nüëÆ **Mod√©rateur:** ${item.data?.moderator || 'Inconnu'}`,
                        inline: false
                    });
                } else {
                    embed.addFields({
                        name: `${globalIndex}. ‚ö†Ô∏è AVERTISSEMENT ${date}`,
                        value: `üìù **Raison:** ${item.reason}\nüëÆ **Mod√©rateur:** ${item.moderator || 'Inconnu'}\nüéØ **Statut:** ${item.active ? 'üü¢ Actif' : 'üî¥ Inactif'}`,
                        inline: false
                    });
                }
            });

            embeds.push(embed);
        }

        return embeds;
    }

    generateDetailedReport(targetUser, history, warnings) {
        const report = [];
        
        report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        report.push(`                RAPPORT D'HISTORIQUE DE MOD√âRATION`);
        report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        report.push('');
        report.push(`üë§ UTILISATEUR: ${targetUser.tag} (${targetUser.id})`);
        report.push(`üìÖ G√âN√âR√â LE: ${new Date().toLocaleString('fr-FR')}`);
        report.push(`üìä ACTIONS TOTALES: ${history.length}`);
        report.push(`‚ö†Ô∏è AVERTISSEMENTS: ${warnings.length} (${warnings.filter(w => w.active).length} actifs)`);
        report.push('');
        
        report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        report.push('                    HISTORIQUE DES ACTIONS');
        report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        
        history.forEach((action, index) => {
            report.push('');
            report.push(`${index + 1}. ACTION: ${action.type.toUpperCase()}`);
            report.push(`   üìÖ Date: ${new Date(action.timestamp).toLocaleString('fr-FR')}`);
            report.push(`   üëÆ Mod√©rateur: ${action.data?.moderator || 'Inconnu'}`);
            report.push(`   üìù Raison: ${action.data?.reason || 'Aucune raison sp√©cifi√©e'}`);
            if (action.data?.duration) {
                report.push(`   ‚è±Ô∏è Dur√©e: ${this.moderationManager.formatDuration(action.data.duration)}`);
            }
        });
        
        if (warnings.length > 0) {
            report.push('');
            report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            report.push('                    AVERTISSEMENTS D√âTAILL√âS');
            report.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
            
            warnings.forEach((warning, index) => {
                report.push('');
                report.push(`${index + 1}. AVERTISSEMENT ${warning.active ? '[ACTIF]' : '[INACTIF]'}`);
                report.push(`   üìÖ Date: ${new Date(warning.timestamp).toLocaleString('fr-FR')}`);
                report.push(`   üëÆ Mod√©rateur: ${warning.moderator || 'Inconnu'}`);
                report.push(`   üìù Raison: ${warning.reason}`);
                report.push(`   üÜî ID: ${warning.id}`);
            });
        }
        
        report.push('');
        report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        report.push('                      FIN DU RAPPORT');
        report.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        
        return report.join('\n');
    }

    // ==================== AUTRES BOUTONS ====================
    async handleStatsButton(interaction) {
        await interaction.deferUpdate();

        const stats = await this.moderationManager.getStats();

        const embed = new EmbedBuilder()
            .setTitle('üìä Statistiques de mod√©ration')
            .setDescription('Statistiques du syst√®me de mod√©ration')
            .addFields(
                { name: 'üìà Actions totales', value: stats.totalActions.toString(), inline: true },
                { name: 'üìÖ Actions aujourd\'hui', value: stats.actionsToday.toString(), inline: true },
                { name: 'üîá Mutes actifs', value: stats.activeMutes.toString(), inline: true },
                { name: '‚ö†Ô∏è Avertissements', value: stats.actionTypes.warn.toString(), inline: true },
                { name: 'üîá Mutes', value: stats.actionTypes.mute.toString(), inline: true },
                { name: 'üë¢ Kicks', value: stats.actionTypes.kick.toString(), inline: true },
                { name: 'üî® Bans', value: stats.actionTypes.ban.toString(), inline: true },
                { name: '‚úÖ Unbans', value: stats.actionTypes.unban.toString(), inline: true },
                { name: 'üìä Total avertissements', value: stats.totalWarnings.toString(), inline: true }
            )
            .setColor('#9b59b6')
            .setTimestamp()
            .setFooter({ text: `Statistiques ‚Ä¢ Mise √† jour automatique` });

        const backButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mod_refresh_panel')
                    .setLabel('üîô Retour au panel')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.editReply({ 
            embeds: [embed],
            components: [backButton]
        });
    }

    // ==================== CONFIGURATION AVANC√âE ====================
    async handleConfigButton(interaction) {
        const configEmbed = new EmbedBuilder()
            .setTitle('‚öôÔ∏è **CONFIGURATION DU SYST√àME DE MOD√âRATION**')
            .setDescription('**Configurez tous les aspects du syst√®me de mod√©ration avanc√©**')
            .addFields(
                { 
                    name: 'üìù Canal de logs', 
                    value: 'D√©finir le canal pour les logs de mod√©ration\n*Permet de suivre toutes les actions*', 
                    inline: true 
                },
                { 
                    name: 'üö® Actions automatiques', 
                    value: 'Configurer les sanctions automatiques\n*Seuils et escalades*', 
                    inline: true 
                },
                { 
                    name: '‚è±Ô∏è Dur√©es par d√©faut', 
                    value: 'Modifier les dur√©es de timeout\n*Mutes et bans temporaires*', 
                    inline: true 
                },
                { 
                    name: 'üõ°Ô∏è Automod√©ration', 
                    value: 'Param√®tres de mod√©ration auto\n*Filtres et d√©tection*', 
                    inline: true 
                },
                { 
                    name: 'üìä Statistiques', 
                    value: 'Gestion des donn√©es et rapports\n*Export et r√©initialisation*', 
                    inline: true 
                },
                { 
                    name: 'üîß Permissions', 
                    value: 'Configuration des r√¥les mod√©rateurs\n*Hi√©rarchie et acc√®s*', 
                    inline: true 
                }
            )
            .setColor('#3498db')
            .setTimestamp()
            .setFooter({ text: 'S√©lectionnez une option pour configurer le syst√®me' });

        const configRow = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('mod_config_select')
                    .setPlaceholder('üîß S√©lectionnez une option de configuration')
                    .addOptions(
                        {
                            label: 'üìù Canal de logs',
                            description: 'D√©finir le canal pour les logs de mod√©ration',
                            value: 'log_channel',
                            emoji: 'üìù'
                        },
                        {
                            label: 'üö® Actions automatiques',
                            description: 'Configurer les seuils de sanctions automatiques',
                            value: 'auto_actions',
                            emoji: 'üö®'
                        },
                        {
                            label: '‚è±Ô∏è Dur√©es par d√©faut',
                            description: 'Modifier les dur√©es de timeout par d√©faut',
                            value: 'default_durations',
                            emoji: '‚è±Ô∏è'
                        },
                        {
                            label: 'üõ°Ô∏è Automod√©ration',
                            description: 'Param√®tres de mod√©ration automatique',
                            value: 'automod_settings',
                            emoji: 'üõ°Ô∏è'
                        },
                        {
                            label: 'üìä Gestion des donn√©es',
                            description: 'Export, sauvegarde et r√©initialisation',
                            value: 'data_management',
                            emoji: 'üìä'
                        },
                        {
                            label: 'üîß Permissions avanc√©es',
                            description: 'Configuration des r√¥les et hi√©rarchie',
                            value: 'permissions_config',
                            emoji: 'üîß'
                        }
                    )
            );

        const buttonRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mod_config_status')
                    .setLabel('üìã √âtat actuel')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('mod_config_reset')
                    .setLabel('üîÑ R√©initialiser')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId('mod_config_export')
                    .setLabel('üìÅ Exporter config')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mod_refresh_panel')
                    .setLabel('üîô Retour')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.reply({ 
            embeds: [configEmbed], 
            components: [configRow, buttonRow],
            ephemeral: true 
        });
    }

    async handleConfigSelect(interaction, value) {
        await interaction.deferReply({ ephemeral: true });

        switch (value) {
            case 'log_channel':
                await this.handleLogChannelConfig(interaction);
                break;
            case 'auto_actions':
                await this.handleAutoActionsConfig(interaction);
                break;
            case 'default_durations':
                await this.handleDurationsConfig(interaction);
                break;
            case 'automod_settings':
                await this.handleAutoModConfig(interaction);
                break;
            case 'data_management':
                await this.handleDataManagementConfig(interaction);
                break;
            case 'permissions_config':
                await this.handlePermissionsConfig(interaction);
                break;
            default:
                await interaction.editReply({
                    content: '‚ùå Option de configuration non reconnue.'
                });
        }
    }

    async handleLogChannelConfig(interaction) {
        const modal = new ModalBuilder()
            .setCustomId('mod_set_log_channel')
            .setTitle('üìù Configurer le canal de logs');

        const channelInput = new TextInputBuilder()
            .setCustomId('channel_id')
            .setLabel('ID ou mention du canal de logs')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('#moderation-logs ou 123456789012345678')
            .setRequired(true);

        const descriptionInput = new TextInputBuilder()
            .setCustomId('description')
            .setLabel('Description du canal (optionnel)')
            .setStyle(TextInputStyle.Paragraph)
            .setPlaceholder('Canal pour enregistrer toutes les actions de mod√©ration...')
            .setRequired(false)
            .setMaxLength(500);

        const firstRow = new ActionRowBuilder().addComponents(channelInput);
        const secondRow = new ActionRowBuilder().addComponents(descriptionInput);
        
        modal.addComponents(firstRow, secondRow);
        await interaction.showModal(modal);
    }

    async handleAutoActionsConfig(interaction) {
        const currentConfig = this.moderationManager.config;
        
        const embed = new EmbedBuilder()
            .setTitle('üö® **CONFIGURATION DES ACTIONS AUTOMATIQUES**')
            .setDescription('**Configurez les seuils pour les sanctions automatiques**')
            .addFields(
                { 
                    name: '‚ö†Ô∏è Seuil de mute automatique', 
                    value: `Actuellement: **${currentConfig.autoMuteThreshold}** avertissements\n*L'utilisateur sera mut√© automatiquement*`, 
                    inline: true 
                },
                { 
                    name: 'üë¢ Seuil de kick automatique', 
                    value: `Actuellement: **${currentConfig.autoKickThreshold}** avertissements\n*L'utilisateur sera expuls√© automatiquement*`, 
                    inline: true 
                },
                { 
                    name: 'üî® Seuil de ban automatique', 
                    value: `Actuellement: **${currentConfig.autoBanThreshold}** avertissements\n*L'utilisateur sera banni automatiquement*`, 
                    inline: true 
                },
                { 
                    name: 'üìã Avertissements maximum', 
                    value: `Actuellement: **${currentConfig.maxWarnings}** avertissements\n*Limite totale d'avertissements*`, 
                    inline: true 
                },
                { 
                    name: 'üîÑ Statut du syst√®me', 
                    value: '‚úÖ **ACTIF** - Les actions automatiques sont appliqu√©es', 
                    inline: true 
                },
                { 
                    name: '‚ö° Actions r√©centes', 
                    value: 'Aucune action automatique r√©cente', 
                    inline: true 
                }
            )
            .setColor('#e74c3c')
            .setTimestamp();

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('config_auto_mute_threshold')
                    .setLabel('‚ö†Ô∏è Modifier seuil mute')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('config_auto_kick_threshold')
                    .setLabel('üë¢ Modifier seuil kick')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('config_auto_ban_threshold')
                    .setLabel('üî® Modifier seuil ban')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId('config_disable_auto')
                    .setLabel('üö´ D√©sactiver auto')
                    .setStyle(ButtonStyle.Danger)
            );

        await interaction.editReply({
            embeds: [embed],
            components: [actionRow]
        });
    }

    async handleDurationsConfig(interaction) {
        const currentConfig = this.moderationManager.config.muteDurations;
        
        const embed = new EmbedBuilder()
            .setTitle('‚è±Ô∏è **CONFIGURATION DES DUR√âES PAR D√âFAUT**')
            .setDescription('**Modifiez les dur√©es de timeout et de sanctions**')
            .addFields(
                { 
                    name: 'üïê Mute court', 
                    value: `${this.formatDuration(currentConfig.short)}\n*Pour infractions mineures*`, 
                    inline: true 
                },
                { 
                    name: 'üïï Mute moyen', 
                    value: `${this.formatDuration(currentConfig.medium)}\n*Pour infractions mod√©r√©es*`, 
                    inline: true 
                },
                { 
                    name: 'üïò Mute long', 
                    value: `${this.formatDuration(currentConfig.long)}\n*Pour infractions graves*`, 
                    inline: true 
                },
                { 
                    name: 'üìÖ Mute tr√®s long', 
                    value: `${this.formatDuration(currentConfig.week)}\n*Pour r√©cidivistes*`, 
                    inline: true 
                },
                { 
                    name: '‚ö° Actions rapides', 
                    value: 'Utilis√©es dans le menu actions rapides', 
                    inline: true 
                },
                { 
                    name: 'üéØ Recommandations', 
                    value: 'Bas√©es sur les meilleures pratiques', 
                    inline: true 
                }
            )
            .setColor('#f39c12')
            .setTimestamp();

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('config_duration_short')
                    .setLabel('üïê Mute court')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('config_duration_medium')
                    .setLabel('üïï Mute moyen')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('config_duration_long')
                    .setLabel('üïò Mute long')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('config_duration_week')
                    .setLabel('üìÖ Mute semaine')
                    .setStyle(ButtonStyle.Primary)
            );

        const presetRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('config_preset_strict')
                    .setLabel('üîí Preset strict')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId('config_preset_balanced')
                    .setLabel('‚öñÔ∏è Preset √©quilibr√©')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('config_preset_lenient')
                    .setLabel('ü§ù Preset cl√©ment')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId('config_preset_reset')
                    .setLabel('üîÑ R√©initialiser')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.editReply({
            embeds: [embed],
            components: [actionRow, presetRow]
        });
    }

    async handleAutoModConfig(interaction) {
        const embed = new EmbedBuilder()
            .setTitle('üõ°Ô∏è **CONFIGURATION DE L\'AUTOMOD√âRATION**')
            .setDescription('**Param√©trez la mod√©ration automatique avanc√©e**')
            .addFields(
                { 
                    name: 'üö´ Filtres de contenu', 
                    value: '‚Ä¢ Liens suspects\n‚Ä¢ Spam de messages\n‚Ä¢ Contenu inappropri√©\n‚Ä¢ Mentions excessives', 
                    inline: true 
                },
                { 
                    name: '‚ö° Actions automatiques', 
                    value: '‚Ä¢ Suppression de message\n‚Ä¢ Avertissement auto\n‚Ä¢ Mute temporaire\n‚Ä¢ Signalement aux mods', 
                    inline: true 
                },
                { 
                    name: 'üìä Statistiques', 
                    value: '‚Ä¢ Messages filtr√©s: 0\n‚Ä¢ Actions auto: 0\n‚Ä¢ Pr√©cision: 98%\n‚Ä¢ Faux positifs: 2%', 
                    inline: true 
                }
            )
            .setColor('#9b59b6')
            .setTimestamp()
            .setFooter({ text: '‚ö†Ô∏è L\'automod√©ration est actuellement en d√©veloppement' });

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('automod_enable_basic')
                    .setLabel('‚úÖ Activer basique')
                    .setStyle(ButtonStyle.Success)
                    .setDisabled(true),
                new ButtonBuilder()
                    .setCustomId('automod_configure_filters')
                    .setLabel('üîß Configurer filtres')
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(true),
                new ButtonBuilder()
                    .setCustomId('automod_test_mode')
                    .setLabel('üß™ Mode test')
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(true),
                new ButtonBuilder()
                    .setCustomId('automod_coming_soon')
                    .setLabel('üöß Bient√¥t disponible')
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(true)
            );

        await interaction.editReply({
            embeds: [embed],
            components: [actionRow]
        });
    }

    async handleDataManagementConfig(interaction) {
        const stats = await this.moderationManager.getStats();
        
        const embed = new EmbedBuilder()
            .setTitle('üìä **GESTION DES DONN√âES DE MOD√âRATION**')
            .setDescription('**G√©rez les donn√©es, statistiques et sauvegardes**')
            .addFields(
                { 
                    name: 'üìà Statistiques actuelles', 
                    value: `‚Ä¢ Actions totales: **${stats.totalActions}**\n‚Ä¢ Actions aujourd'hui: **${stats.actionsToday}**\n‚Ä¢ Mutes actifs: **${stats.activeMutes}**\n‚Ä¢ Avertissements actifs: **${stats.totalWarnings}**`, 
                    inline: true 
                },
                { 
                    name: 'üíæ Donn√©es stock√©es', 
                    value: '‚Ä¢ Historique des actions\n‚Ä¢ Avertissements\n‚Ä¢ Configuration\n‚Ä¢ Logs de mod√©ration', 
                    inline: true 
                },
                { 
                    name: 'üîÑ Maintenance', 
                    value: '‚Ä¢ Nettoyage automatique\n‚Ä¢ Archivage mensuel\n‚Ä¢ Sauvegarde quotidienne\n‚Ä¢ Optimisation DB', 
                    inline: true 
                }
            )
            .setColor('#16a085')
            .setTimestamp();

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('data_export_all')
                    .setLabel('üìÅ Exporter tout')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('data_cleanup_old')
                    .setLabel('üßπ Nettoyer ancien')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('data_reset_stats')
                    .setLabel('üîÑ Reset stats')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId('data_backup_now')
                    .setLabel('üíæ Sauvegarde')
                    .setStyle(ButtonStyle.Success)
            );

        await interaction.editReply({
            embeds: [embed],
            components: [actionRow]
        });
    }

    async handlePermissionsConfig(interaction) {
        const guild = interaction.guild;
        const moderatorRoles = guild.roles.cache.filter(role => 
            role.permissions.has(PermissionFlagsBits.ModerateMembers)
        );

        const embed = new EmbedBuilder()
            .setTitle('üîß **CONFIGURATION DES PERMISSIONS**')
            .setDescription('**G√©rez les r√¥les et permissions de mod√©ration**')
            .addFields(
                { 
                    name: 'üëÆ R√¥les mod√©rateurs d√©tect√©s', 
                    value: moderatorRoles.size > 0 ? 
                        moderatorRoles.map(role => `‚Ä¢ ${role.name} (${role.members.size} membres)`).slice(0, 5).join('\n') :
                        'Aucun r√¥le mod√©rateur d√©tect√©', 
                    inline: false 
                },
                { 
                    name: 'üõ°Ô∏è Permissions requises', 
                    value: '‚Ä¢ Mod√©rer les membres\n‚Ä¢ G√©rer les messages\n‚Ä¢ Expulser les membres\n‚Ä¢ Bannir les membres', 
                    inline: true 
                },
                { 
                    name: '‚öôÔ∏è Configuration avanc√©e', 
                    value: '‚Ä¢ Hi√©rarchie des r√¥les\n‚Ä¢ Permissions par canal\n‚Ä¢ Restrictions d\'actions\n‚Ä¢ Logs d\'audit', 
                    inline: true 
                }
            )
            .setColor('#8e44ad')
            .setTimestamp();

        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('perms_check_roles')
                    .setLabel('üîç V√©rifier r√¥les')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('perms_setup_hierarchy')
                    .setLabel('üìä Hi√©rarchie')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('perms_test_permissions')
                    .setLabel('üß™ Tester perms')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('perms_audit_log')
                    .setLabel('üìã Audit log')
                    .setStyle(ButtonStyle.Success)
            );

        await interaction.editReply({
            embeds: [embed],
            components: [actionRow]
        });
    }

    formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) return `${days}j ${hours % 24}h`;
        if (hours > 0) return `${hours}h ${minutes % 60}m`;
        if (minutes > 0) return `${minutes}m`;
        return `${seconds}s`;
    }

    async handleRefreshPanel(interaction) {
        await interaction.deferUpdate();

        const embed = new EmbedBuilder()
            .setTitle('üõ°Ô∏è Panel de Mod√©ration')
            .setDescription('S√©lectionnez une action de mod√©ration √† effectuer')
            .addFields(
                { name: '‚ö†Ô∏è Avertissement', value: 'Donner un avertissement √† un utilisateur', inline: true },
                { name: 'üîá Mute', value: 'Mettre un utilisateur en sourdine', inline: true },
                { name: 'üë¢ Kick', value: 'Expulser un utilisateur du serveur', inline: true },
                { name: 'üî® Ban', value: 'Bannir un utilisateur d√©finitivement', inline: true },
                { name: 'üìã Historique', value: 'Consulter l\'historique d\'un utilisateur', inline: true },
                { name: 'üìä Statistiques', value: 'Voir les stats de mod√©ration', inline: true }
            )
            .setColor('#3498db')
            .setTimestamp()
            .setFooter({ text: 'Syst√®me de mod√©ration ‚Ä¢ Panel actualis√©' });

        const actionRow1 = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mod_warn_user')
                    .setLabel('‚ö†Ô∏è Avertir')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('mod_mute_user')
                    .setLabel('üîá Muter')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('mod_kick_user')
                    .setLabel('üë¢ Kick')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId('mod_ban_user')
                    .setLabel('üî® Ban')
                    .setStyle(ButtonStyle.Danger)
            );

        const actionRow2 = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mod_history_user')
                    .setLabel('üìã Historique')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mod_stats')
                    .setLabel('üìä Statistiques')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('mod_config')
                    .setLabel('‚öôÔ∏è Configuration')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('mod_refresh_panel')
                    .setLabel('üîÑ Actualiser')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.editReply({
            embeds: [embed],
            components: [actionRow1, actionRow2]
        });
    }

    // ==================== NAVIGATION DE L'HISTORIQUE ====================
    async handleHistoryNavigation(interaction) {
        const customId = interaction.customId;
        const userId = customId.split('_')[2]; // Extraire l'ID utilisateur
        
        if (customId.startsWith('history_prev_')) {
            await this.handleHistoryPageChange(interaction, userId, -1);
        } else if (customId.startsWith('history_next_')) {
            await this.handleHistoryPageChange(interaction, userId, 1);
        }
    }

    async handleHistoryPageChange(interaction, userId, direction) {
        await interaction.deferUpdate();

        try {
            const targetUser = await this.resolveUser(userId);
            if (!targetUser) {
                return await interaction.editReply({
                    content: '‚ùå Utilisateur non trouv√©.'
                });
            }

            const history = await this.moderationManager.getUserHistory(targetUser.id);
            const warnings = await this.moderationManager.getUserWarnings(targetUser.id);

            // G√©n√©rer les embeds complets
            const fullHistoryEmbeds = await this.generateFullHistoryEmbeds(targetUser, history, warnings);
            
            // Obtenir la page actuelle depuis le bouton
            const currentMessage = interaction.message;
            const currentPageButton = currentMessage.components[0].components[1];
            const currentPageText = currentPageButton.data.label;
            const currentPage = parseInt(currentPageText.split('/')[0].replace('Page ', '')) - 1;
            
            // Calculer la nouvelle page
            const newPage = Math.max(0, Math.min(fullHistoryEmbeds.length - 1, currentPage + direction));
            const totalPages = fullHistoryEmbeds.length;

            // Cr√©er les nouveaux boutons de navigation
            const navigationRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`history_prev_${userId}`)
                        .setLabel('‚óÄÔ∏è Pr√©c√©dent')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(newPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`history_page_${userId}`)
                        .setLabel(`Page ${newPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`history_next_${userId}`)
                        .setLabel('Suivant ‚ñ∂Ô∏è')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(newPage === totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId(`mod_export_history_${userId}`)
                        .setLabel('üìÅ Exporter')
                        .setStyle(ButtonStyle.Success)
                );

            await interaction.editReply({
                embeds: [fullHistoryEmbeds[newPage]],
                components: [navigationRow]
            });

        } catch (error) {
            await interaction.editReply({
                content: `‚ùå Erreur lors de la navigation: ${error.message}`
            });
        }
    }

    // ==================== G√âN√âRATION DES EMBEDS D'HISTORIQUE ====================
    async generateFullHistoryEmbeds(targetUser, history, warnings) {
        const embeds = [];
        const itemsPerPage = 5;

        // Page 1: Informations g√©n√©rales
        const member = await this.client.guilds.cache.first()?.members.fetch(targetUser.id).catch(() => null);
        
        const mainEmbed = new EmbedBuilder()
            .setTitle('üìã **HISTORIQUE COMPLET DE MOD√âRATION**')
            .setDescription(`**Profil d√©taill√© de ${targetUser.tag}**`)
            .addFields(
                { name: 'üë§ Utilisateur', value: `${targetUser.tag}`, inline: true },
                { name: 'üÜî ID Discord', value: `\`${targetUser.id}\``, inline: true },
                { name: 'üìÖ Compte cr√©√©', value: `<t:${Math.floor(targetUser.createdTimestamp / 1000)}:R>`, inline: true }
            )
            .setColor('#3498db')
            .setThumbnail(targetUser.displayAvatarURL())
            .setTimestamp();

        if (member) {
            mainEmbed.addFields(
                { name: 'üì• Rejoint le serveur', value: `<t:${Math.floor(member.joinedTimestamp / 1000)}:R>`, inline: true },
                { name: 'üëë R√¥les', value: member.roles.cache.size > 1 ? `${member.roles.cache.size - 1} r√¥les` : 'Aucun r√¥le', inline: true },
                { name: 'üíé Statut', value: member.premiumSince ? 'üåü Booster' : 'üë§ Membre', inline: true }
            );
        }

        // Statistiques des sanctions
        const actionCounts = {
            warn: history.filter(h => h.type === 'warn').length,
            mute: history.filter(h => h.type === 'mute').length,
            kick: history.filter(h => h.type === 'kick').length,
            ban: history.filter(h => h.type === 'ban').length,
            unban: history.filter(h => h.type === 'unban').length
        };

        mainEmbed.addFields(
            { name: '‚ö†Ô∏è Avertissements', value: `${actionCounts.warn} total\n${warnings.filter(w => w.active).length} actifs`, inline: true },
            { name: 'üîá Mutes', value: `${actionCounts.mute} total`, inline: true },
            { name: 'üë¢ Expulsions', value: `${actionCounts.kick} total`, inline: true },
            { name: 'üî® Bannissements', value: `${actionCounts.ban} total`, inline: true },
            { name: '‚úÖ D√©bannissements', value: `${actionCounts.unban} total`, inline: true },
            { name: 'üìà Score de risque', value: this.calculateRiskScore(actionCounts), inline: true }
        );

        embeds.push(mainEmbed);

        // Pages pour les avertissements actifs
        const activeWarnings = warnings.filter(w => w.active);
        if (activeWarnings.length > 0) {
            for (let i = 0; i < activeWarnings.length; i += itemsPerPage) {
                const pageWarnings = activeWarnings.slice(i, i + itemsPerPage);
                const warningsEmbed = new EmbedBuilder()
                    .setTitle(`‚ö†Ô∏è **AVERTISSEMENTS ACTIFS** (Page ${Math.floor(i / itemsPerPage) + 1})`)
                    .setColor('#ffaa00');

                const warningsList = pageWarnings.map((w, index) => {
                    const globalIndex = i + index + 1;
                    const date = `<t:${Math.floor(w.timestamp / 1000)}:R>`;
                    const moderator = w.moderator || 'Inconnu';
                    const reason = w.reason.length > 100 ? w.reason.substring(0, 100) + '...' : w.reason;
                    return `**${globalIndex}.** ${reason}\nüìÖ ${date} ‚Ä¢ üëÆ ${moderator}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
                }).join('\n\n');

                warningsEmbed.setDescription(warningsList);
                warningsEmbed.setFooter({ 
                    text: `Avertissement ${i + 1}-${Math.min(i + itemsPerPage, activeWarnings.length)} sur ${activeWarnings.length}` 
                });

                embeds.push(warningsEmbed);
            }
        }

        // Pages pour l'historique complet
        if (history.length > 0) {
            const sortedHistory = history.sort((a, b) => b.timestamp - a.timestamp);
            
            for (let i = 0; i < sortedHistory.length; i += itemsPerPage) {
                const pageHistory = sortedHistory.slice(i, i + itemsPerPage);
                const historyEmbed = new EmbedBuilder()
                    .setTitle(`üìú **HISTORIQUE COMPLET** (Page ${Math.floor(i / itemsPerPage) + 1})`)
                    .setColor('#9b59b6');

                const historyList = pageHistory.map((h, index) => {
                    const globalIndex = i + index + 1;
                    const action = this.getActionEmoji(h.type) + ' ' + h.type.toUpperCase();
                    const timestamp = `<t:${Math.floor(h.timestamp / 1000)}:F>`;
                    const moderator = h.data.moderator || 'Syst√®me';
                    const reason = h.data.reason?.substring(0, 80) || 'Aucune raison';
                    const duration = h.data.duration ? ` (${this.moderationManager.formatDuration(h.data.duration)})` : '';
                    
                    return `**${globalIndex}.** ${action}${duration}\nüìù ${reason}\nüìÖ ${timestamp}\nüëÆ ${moderator}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
                }).join('\n\n');

                historyEmbed.setDescription(historyList);
                historyEmbed.setFooter({ 
                    text: `Action ${i + 1}-${Math.min(i + itemsPerPage, sortedHistory.length)} sur ${sortedHistory.length}` 
                });

                embeds.push(historyEmbed);
            }
        }

        return embeds;
    }

    // ==================== G√âN√âRATION DE RAPPORT D√âTAILL√â ====================
    generateDetailedReport(targetUser, history, warnings) {
        const now = new Date();
        const activeWarnings = warnings.filter(w => w.active);
        
        let report = `üõ°Ô∏è RAPPORT DE MOD√âRATION D√âTAILL√â
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üë§ INFORMATIONS UTILISATEUR
‚Ä¢ Nom: ${targetUser.tag}
‚Ä¢ ID: ${targetUser.id}
‚Ä¢ Compte cr√©√©: ${new Date(targetUser.createdTimestamp).toLocaleString('fr-FR')}
‚Ä¢ Rapport g√©n√©r√©: ${now.toLocaleString('fr-FR')}

üìä R√âSUM√â DES SANCTIONS
‚Ä¢ Actions totales: ${history.length}
‚Ä¢ Avertissements actifs: ${activeWarnings.length}
‚Ä¢ Avertissements total: ${warnings.length}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ö†Ô∏è AVERTISSEMENTS ACTIFS (${activeWarnings.length})
`;

        if (activeWarnings.length > 0) {
            activeWarnings.forEach((warning, index) => {
                const date = new Date(warning.timestamp).toLocaleString('fr-FR');
                report += `
${index + 1}. [${warning.id}] ${warning.reason}
   ‚Ä¢ Date: ${date}
   ‚Ä¢ Mod√©rateur: ${warning.moderator}
   ‚Ä¢ Statut: ${warning.active ? 'ACTIF' : 'INACTIF'}`;
            });
        } else {
            report += '\nAucun avertissement actif.';
        }

        report += `

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìú HISTORIQUE COMPLET DES ACTIONS (${history.length})
`;

        if (history.length > 0) {
            const sortedHistory = history.sort((a, b) => b.timestamp - a.timestamp);
            
            sortedHistory.forEach((action, index) => {
                const date = new Date(action.timestamp).toLocaleString('fr-FR');
                const duration = action.data.duration ? ` (Dur√©e: ${this.moderationManager.formatDuration(action.data.duration)})` : '';
                
                report += `
${index + 1}. ${action.type.toUpperCase()}${duration}
   ‚Ä¢ Date: ${date}
   ‚Ä¢ Mod√©rateur: ${action.data.moderator || 'Syst√®me'}
   ‚Ä¢ Raison: ${action.data.reason || 'Aucune raison'}
   ‚Ä¢ ID: ${action.data.id || 'N/A'}`;
            });
        } else {
            report += '\nAucune action dans l\'historique.';
        }

        report += `

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìà ANALYSE DES RISQUES
‚Ä¢ Score de risque: ${this.calculateRiskScore({
    warn: history.filter(h => h.type === 'warn').length,
    mute: history.filter(h => h.type === 'mute').length,
    kick: history.filter(h => h.type === 'kick').length,
    ban: history.filter(h => h.type === 'ban').length,
    unban: history.filter(h => h.type === 'unban').length
})}
‚Ä¢ Tendance: ${activeWarnings.length > 3 ? 'SURVEILLENCE RECOMMAND√âE' : 'NORMALE'}
‚Ä¢ Derni√®re action: ${history.length > 0 ? new Date(Math.max(...history.map(h => h.timestamp))).toLocaleString('fr-FR') : 'Aucune'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Ce rapport a √©t√© g√©n√©r√© automatiquement par le syst√®me de mod√©ration.
Pour toute question, contactez l'√©quipe de mod√©ration.
`;

        return report;
    }

    calculateRiskScore(actionCounts) {
        const score = (actionCounts.warn * 1) + (actionCounts.mute * 2) + 
                     (actionCounts.kick * 5) + (actionCounts.ban * 10);
        
        if (score === 0) return 'üü¢ Aucun risque';
        if (score < 5) return 'üü° Risque faible';
        if (score < 15) return 'üü† Risque mod√©r√©';
        return 'üî¥ Risque √©lev√©';
    }

    getActionEmoji(actionType) {
        const emojis = {
            'warn': '‚ö†Ô∏è',
            'mute': 'üîá',
            'kick': 'üë¢',
            'ban': 'üî®',
            'unban': '‚úÖ',
            'unmute': 'üîä',
            'timeout': '‚è±Ô∏è'
        };
        return emojis[actionType] || 'üìù';
    }

    // ==================== MODALS ET AUTRES HANDLERS ====================
    async handleWarnModal(interaction) {
        // Impl√©mentation des modals...
    }

    async handleMuteModal(interaction) {
        // Impl√©mentation des modals...
    }

    async handleKickModal(interaction) {
        // Impl√©mentation des modals...
    }

    async handleBanModal(interaction) {
        // Impl√©mentation des modals...
    }

    async handleUnbanModal(interaction) {
        // Impl√©mentation des modals...
    }

    async handleUnmuteModal(interaction) {
        // Impl√©mentation des modals...
    }

    async handleSetLogChannel(interaction) {
        // Impl√©mentation de la configuration...
    }

    async handleConfigSelect(interaction, value) {
        // Impl√©mentation de la s√©lection de config...
    }

    async handleClearWarnings(interaction) {
        // Impl√©mentation du nettoyage des avertissements...
    }

    async handleQuickActions(interaction) {
        // Impl√©mentation des actions rapides...
    }

    async handleQuickActionButton(interaction) {
        // Impl√©mentation des boutons d'actions rapides...
    }

    async handleQuickWarnModal(interaction) {
        // Impl√©mentation du modal d'avertissement rapide...
    }

    async handleQuickMuteModal(interaction) {
        // Impl√©mentation du modal de mute rapide...
    }

    async handleQuickUserInfoModal(interaction) {
        // Impl√©mentation du modal d'info utilisateur...
    }

    async handleQuickClearWarnsModal(interaction) {
        // Impl√©mentation du modal de nettoyage rapide...
    }

    async handleUnbanButton(interaction) {
        // Impl√©mentation du bouton unban...
    }

    async handleUnmuteButton(interaction) {
        // Impl√©mentation du bouton unmute...
    }
}
