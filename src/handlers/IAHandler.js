import Logger from '../utils/Logger.js';
import { EmbedBuilder, MessageFlags } from 'discord.js';

const logger = new Logger();

export async function handleIAButtons(interaction) {
    const { customId } = interaction;

    try {
        if (customId.startsWith('ia_deploy_')) {
            await handleIADeploy(interaction);
        }
        else if (customId.startsWith('ia_customize_')) {
            await handleIACustomize(interaction);
        }
        else if (customId.startsWith('ia_alternatives_')) {
            await handleIAAlternatives(interaction);
        }
        else if (customId.startsWith('ia_export_json_')) {
            await handleIAExportJSON(interaction);
        }
        else if (customId.startsWith('ia_save_template_')) {
            await handleIASaveTemplate(interaction);
        }
        else if (customId.startsWith('ia_analytics_')) {
            await handleIAAnalytics(interaction);
        }

    } catch (error) {
        logger.error('Erreur lors de la gestion des boutons IA:', error);
        
        try {
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({
                    content: '‚ùå Une erreur est survenue lors du traitement IA.',
                    flags: MessageFlags.Ephemeral
                });
            }
        } catch (replyError) {
            logger.error('Impossible de r√©pondre √† l\'erreur IA:', replyError);
        }
    }
}

async function handleIADeploy(interaction) {
    try {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });

        const userId = interaction.customId.split('_')[2];
        if (userId !== interaction.user.id) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas utiliser cette interaction.'
            });
        }

        const iaData = interaction.client.embedIA?.get(interaction.user.id);
        if (!iaData) {
            return await interaction.editReply({
                content: '‚ùå Donn√©es IA expir√©es. Veuillez relancer la g√©n√©ration.'
            });
        }

        const targetChannel = interaction.guild.channels.cache.get(iaData.channelId) || interaction.channel;
        const sentMessage = await targetChannel.send({ embeds: [iaData.generatedEmbed] });

        logger.success(`Embed IA d√©ploy√© par ${interaction.user.tag} dans #${targetChannel.name}`);

        await interaction.editReply({
            content: `üöÄ **Embed d√©ploy√© avec succ√®s !**\n\nüìç **Canal :** ${targetChannel}\nüÜî **Message ID :** \`${sentMessage.id}\`\nüß† **G√©n√©r√© par IA** avec un score de qualit√© de **${iaData.analysis.qualityScore}/100**\n\n[üîó Aller au message](${sentMessage.url})`
        });

    } catch (error) {
        logger.error('Erreur lors du d√©ploiement IA:', error);
        await interaction.editReply({
            content: '‚ùå Erreur lors du d√©ploiement de l\'embed.'
        });
    }
}

async function handleIACustomize(interaction) {
    try {
        const userId = interaction.customId.split('_')[2];
        if (userId !== interaction.user.id) {
            return await interaction.reply({
                content: '‚ùå Vous ne pouvez pas utiliser cette interaction.',
                flags: MessageFlags.Ephemeral
            });
        }

        const iaData = interaction.client.embedIA?.get(interaction.user.id);
        if (!iaData) {
            return await interaction.reply({
                content: '‚ùå Donn√©es IA expir√©es. Veuillez relancer la g√©n√©ration.',
                flags: MessageFlags.Ephemeral
            });
        }

        const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
        
        const customizeModal = new ModalBuilder()
            .setCustomId('ia_customize_modal')
            .setTitle('‚öôÔ∏è Personnaliser l\'Embed IA');

        const titleInput = new TextInputBuilder()
            .setCustomId('ia_custom_title')
            .setLabel('üìã Titre')
            .setStyle(TextInputStyle.Short)
            .setValue(iaData.generatedContent.title)
            .setRequired(true)
            .setMaxLength(256);

        const descriptionInput = new TextInputBuilder()
            .setCustomId('ia_custom_description')
            .setLabel('üìÑ Description')
            .setStyle(TextInputStyle.Paragraph)
            .setValue(iaData.generatedContent.description)
            .setRequired(true)
            .setMaxLength(4096);

        const colorInput = new TextInputBuilder()
            .setCustomId('ia_custom_color')
            .setLabel('üé® Couleur (hex)')
            .setStyle(TextInputStyle.Short)
            .setValue(iaData.generatedContent.color)
            .setRequired(false);

        customizeModal.addComponents(
            new ActionRowBuilder().addComponents(titleInput),
            new ActionRowBuilder().addComponents(descriptionInput),
            new ActionRowBuilder().addComponents(colorInput)
        );

        await interaction.showModal(customizeModal);

    } catch (error) {
        await interaction.reply({
            content: '‚ùå Erreur lors de la personnalisation.',
            flags: MessageFlags.Ephemeral
        });
    }
}

async function handleIAAlternatives(interaction) {
    try {
        await interaction.deferReply({ flags: MessageFlags.Ephemeral });

        const userId = interaction.customId.split('_')[2];
        if (userId !== interaction.user.id) {
            return await interaction.editReply({
                content: '‚ùå Vous ne pouvez pas utiliser cette interaction.'
            });
        }

        const iaData = interaction.client.embedIA?.get(interaction.user.id);
        if (!iaData) {
            return await interaction.editReply({
                content: '‚ùå Donn√©es IA expir√©es. Veuillez relancer la g√©n√©ration.'
            });
        }

        const alternatives = generateIAAlternatives(iaData.analysis, iaData.originalDescription);

        const alternativesEmbed = new EmbedBuilder()
            .setTitle('üîÑ ALTERNATIVES IA G√âN√âR√âES')
            .setDescription('Voici 3 alternatives g√©n√©r√©es par l\'IA pour votre embed :')
            .setColor('#ff6b9d')
            .setFooter({ text: 'Alternatives IA', iconURL: interaction.client.user.displayAvatarURL() })
            .setTimestamp();

        alternatives.forEach((alt, index) => {
            alternativesEmbed.addFields({
                name: `${index + 1}Ô∏è‚É£ ${alt.title}`,
                value: `${alt.description.substring(0, 200)}${alt.description.length > 200 ? '...' : ''}\n**Style :** ${alt.style}`,
                inline: false
            });
        });

        await interaction.editReply({
            embeds: [alternativesEmbed]
        });

    } catch (error) {
        logger.error('Erreur lors de la g√©n√©ration d\'alternatives:', error);
        await interaction.editReply({
            content: '‚ùå Erreur lors de la g√©n√©ration d\'alternatives.'
        });
    }
}

async function handleIAExportJSON(interaction) {
    try {
        const userId = interaction.customId.split('_')[3];
        if (userId !== interaction.user.id) {
            return await interaction.reply({
                content: '‚ùå Vous ne pouvez pas utiliser cette interaction.',
                flags: MessageFlags.Ephemeral
            });
        }

        const iaData = interaction.client.embedIA?.get(interaction.user.id);
        if (!iaData) {
            return await interaction.reply({
                content: '‚ùå Donn√©es IA expir√©es. Veuillez relancer la g√©n√©ration.',
                flags: MessageFlags.Ephemeral
            });
        }

        const embedJson = JSON.stringify(iaData.generatedEmbed.toJSON(), null, 2);
        
        await interaction.reply({
            content: `üì§ **Export JSON de votre Embed IA :**\n\n\`\`\`json\n${embedJson.substring(0, 1800)}\n\`\`\`${embedJson.length > 1800 ? '\n*JSON tronqu√© pour l\'affichage*' : ''}\n\nüí° **Copiez ce code pour le r√©utiliser avec** \`/embed json import\``,
            flags: MessageFlags.Ephemeral
        });

    } catch (error) {
        await interaction.reply({
            content: '‚ùå Erreur lors de l\'export JSON.',
            flags: MessageFlags.Ephemeral
        });
    }
}

async function handleIASaveTemplate(interaction) {
    try {
        const userId = interaction.customId.split('_')[3];
        if (userId !== interaction.user.id) {
            return await interaction.reply({
                content: '‚ùå Vous ne pouvez pas utiliser cette interaction.',
                flags: MessageFlags.Ephemeral
            });
        }

        const iaData = interaction.client.embedIA?.get(interaction.user.id);
        if (!iaData) {
            return await interaction.reply({
                content: '‚ùå Donn√©es IA expir√©es. Veuillez relancer la g√©n√©ration.',
                flags: MessageFlags.Ephemeral
            });
        }

        if (!interaction.client.embedFavorites) {
            interaction.client.embedFavorites = new Map();
        }

        const userFavorites = interaction.client.embedFavorites.get(interaction.user.id) || [];
        
        const newFavorite = {
            name: `IA - ${iaData.analysis.context}`,
            type: 'IA Generated',
            createdAt: new Date().toLocaleDateString('fr-FR'),
            data: iaData.generatedEmbed.toJSON(),
            analysis: iaData.analysis
        };

        userFavorites.push(newFavorite);
        interaction.client.embedFavorites.set(interaction.user.id, userFavorites);

        await interaction.reply({
            content: `üíæ **Template sauvegard√© !**\n\nüìù **Nom :** ${newFavorite.name}\nüìÖ **Date :** ${newFavorite.createdAt}\nüß† **Score IA :** ${iaData.analysis.qualityScore}/100\n\n‚ú® Utilisez \`/embed favoris list\` pour voir tous vos favoris.`,
            flags: MessageFlags.Ephemeral
        });

    } catch (error) {
        await interaction.reply({
            content: '‚ùå Erreur lors de la sauvegarde.',
            flags: MessageFlags.Ephemeral
        });
    }
}

async function handleIAAnalytics(interaction) {
    try {
        const userId = interaction.customId.split('_')[2];
        if (userId !== interaction.user.id) {
            return await interaction.reply({
                content: '‚ùå Vous ne pouvez pas utiliser cette interaction.',
                flags: MessageFlags.Ephemeral
            });
        }

        const iaData = interaction.client.embedIA?.get(interaction.user.id);
        if (!iaData) {
            return await interaction.reply({
                content: '‚ùå Donn√©es IA expir√©es. Veuillez relancer la g√©n√©ration.',
                flags: MessageFlags.Ephemeral
            });
        }

        const analyticsEmbed = new EmbedBuilder()
            .setTitle('üìä ANALYTICS IA D√âTAILL√âES')
            .setDescription('Analyse compl√®te de votre embed g√©n√©r√© par l\'IA')
            .setColor('#00d2d3')
            .addFields(
                { name: 'üéØ Contexte d√©tect√©', value: iaData.analysis.context, inline: true },
                { name: 'üé® Style appliqu√©', value: iaData.analysis.styleDescription, inline: true },
                { name: 'üìä Score de qualit√©', value: `${iaData.analysis.qualityScore}/100`, inline: true },
                { name: 'üî§ Longueur description', value: `${iaData.originalDescription.length} caract√®res`, inline: true },
                { name: 'üìù Ton utilis√©', value: iaData.tone, inline: true },
                { name: '‚è±Ô∏è G√©n√©r√© le', value: new Date(iaData.timestamp).toLocaleString('fr-FR'), inline: true },
                { name: 'üî• Points forts', value: iaData.analysis.strengths.map(s => `‚Ä¢ ${s}`).join('\n'), inline: false },
                { name: 'üé® Couleur choisie', value: iaData.analysis.color, inline: true },
                { name: 'üìã Champs g√©n√©r√©s', value: `${iaData.generatedContent.fields?.length || 0} champs`, inline: true }
            )
            .setFooter({ text: 'Analytics IA Avanc√©es', iconURL: interaction.client.user.displayAvatarURL() })
            .setTimestamp();

        await interaction.reply({
            embeds: [analyticsEmbed],
            flags: MessageFlags.Ephemeral
        });

    } catch (error) {
        await interaction.reply({
            content: '‚ùå Erreur lors de la g√©n√©ration des analytics.',
            flags: MessageFlags.Ephemeral
        });
    }
}

function generateIAAlternatives(analysis, originalDescription) {
    const alternatives = [];
    
    alternatives.push({
        title: 'üé® STYLE ALTERNATIF',
        description: `**Approche Cr√©ative**\n\n${originalDescription}\n\n*Cette version met l'accent sur l'aspect visuel et cr√©atif de votre message.*`,
        style: 'Cr√©atif & Visuel'
    });

    alternatives.push({
        title: 'üìã VERSION PROFESSIONNELLE',
        description: `**Communication Officielle**\n\nNous souhaitons porter √† votre attention les informations suivantes :\n\n${originalDescription}\n\n*Cette communication s'inscrit dans le cadre de nos √©changes officiels.*`,
        style: 'Formel & Professionnel'
    });

    alternatives.push({
        title: 'üòä VERSION CONVIVIALE',
        description: `**Hey la communaut√© ! üëã**\n\n${originalDescription}\n\nOn esp√®re que √ßa vous plaira ! N'h√©sitez pas si vous avez des questions ! üòÑ`,
        style: 'D√©contract√© & Amical'
    });

    return alternatives;
}
